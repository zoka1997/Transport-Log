{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/view_model/view_data_generator.js)\r\n * Version: 22.1.6\r\n * Build date: Tue Oct 18 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport dateUtils from \"../../../../core/utils/date\";\nimport { HORIZONTAL_GROUP_ORIENTATION } from \"../../constants\";\nimport { getAllGroups, getGroupCount } from \"../../resources/utils\";\nimport { calculateCellIndex, calculateDayDuration, isHorizontalView, getStartViewDateWithoutDST, getDisplayedRowCount, getTotalCellCountByCompleteData, getTotalRowCountByCompleteData, getDisplayedCellCount } from \"../../../../renovation/ui/scheduler/view_model/to_test/views/utils/base\";\nimport { getIsGroupedAllDayPanel, getKeyByGroup } from \"../../../../renovation/ui/scheduler/workspaces/utils\";\nvar HOUR_MS = dateUtils.dateToMilliseconds(\"hour\");\nvar DAY_MS = dateUtils.dateToMilliseconds(\"day\");\nexport class ViewDataGenerator {\n  get daysInInterval() {\n    return 1;\n  }\n\n  get isWorkView() {\n    return false;\n  }\n\n  get tableAllDay() {\n    return false;\n  }\n\n  isSkippedDate() {\n    return false;\n  }\n\n  getStartViewDate(options) {\n    return this._calculateStartViewDate(options);\n  }\n\n  getCompleteViewDataMap(options) {\n    var {\n      groups: groups,\n      isGroupedByDate: isGroupedByDate,\n      isHorizontalGrouping: isHorizontalGrouping,\n      isVerticalGrouping: isVerticalGrouping,\n      intervalCount: intervalCount,\n      currentDate: currentDate,\n      viewType: viewType,\n      startDayHour: startDayHour,\n      endDayHour: endDayHour,\n      hoursInterval: hoursInterval\n    } = options;\n\n    this._setVisibilityDates(options);\n\n    this.setHiddenInterval(startDayHour, endDayHour, hoursInterval);\n    var groupsList = getAllGroups(groups);\n    var cellCountInGroupRow = this.getCellCount({\n      intervalCount: intervalCount,\n      currentDate: currentDate,\n      viewType: viewType,\n      startDayHour: startDayHour,\n      endDayHour: endDayHour,\n      hoursInterval: hoursInterval\n    });\n    var rowCountInGroup = this.getRowCount({\n      intervalCount: intervalCount,\n      currentDate: currentDate,\n      viewType: viewType,\n      hoursInterval: hoursInterval,\n      startDayHour: startDayHour,\n      endDayHour: endDayHour\n    });\n    var viewDataMap = [];\n\n    var allDayPanelData = this._generateAllDayPanelData(options, rowCountInGroup, cellCountInGroupRow);\n\n    var viewCellsData = this._generateViewCellsData(options, rowCountInGroup, cellCountInGroupRow);\n\n    allDayPanelData && viewDataMap.push(allDayPanelData);\n    viewDataMap.push(...viewCellsData);\n\n    if (isHorizontalGrouping && !isGroupedByDate) {\n      viewDataMap = this._transformViewDataMapForHorizontalGrouping(viewDataMap, groupsList);\n    }\n\n    if (isVerticalGrouping) {\n      viewDataMap = this._transformViewDataMapForVerticalGrouping(viewDataMap, groupsList);\n    }\n\n    if (isGroupedByDate) {\n      viewDataMap = this._transformViewDataMapForGroupingByDate(viewDataMap, groupsList);\n    }\n\n    var completeViewDataMap = this._addKeysToCells(viewDataMap);\n\n    return completeViewDataMap;\n  }\n\n  _transformViewDataMapForHorizontalGrouping(viewDataMap, groupsList) {\n    var result = viewDataMap.map(row => row.slice());\n    groupsList.slice(1).forEach((groups, index) => {\n      var groupIndex = index + 1;\n      viewDataMap.forEach((row, rowIndex) => {\n        var nextGroupRow = row.map(cellData => _extends({}, cellData, {\n          groups: groups,\n          groupIndex: groupIndex\n        }));\n        result[rowIndex].push(...nextGroupRow);\n      });\n    });\n    return result;\n  }\n\n  _transformViewDataMapForVerticalGrouping(viewDataMap, groupsList) {\n    var result = viewDataMap.map(row => row.slice());\n    groupsList.slice(1).forEach((groups, index) => {\n      var groupIndex = index + 1;\n      var nextGroupMap = viewDataMap.map(cellsRow => {\n        var nextRow = cellsRow.map(cellData => _extends({}, cellData, {\n          groupIndex: groupIndex,\n          groups: groups\n        }));\n        return nextRow;\n      });\n      result.push(...nextGroupMap);\n    });\n    return result;\n  }\n\n  _transformViewDataMapForGroupingByDate(viewDataMap, groupsList) {\n    var correctedGroupList = groupsList.slice(1);\n    var correctedGroupCount = correctedGroupList.length;\n    var result = viewDataMap.map(cellsRow => {\n      var groupedByDateCellsRow = cellsRow.reduce((currentRow, cell) => {\n        var rowWithCurrentCell = [...currentRow, _extends({}, cell, {\n          isFirstGroupCell: true,\n          isLastGroupCell: 0 === correctedGroupCount\n        }), ...correctedGroupList.map((groups, index) => _extends({}, cell, {\n          groups: groups,\n          groupIndex: index + 1,\n          isFirstGroupCell: false,\n          isLastGroupCell: index === correctedGroupCount - 1\n        }))];\n        return rowWithCurrentCell;\n      }, []);\n      return groupedByDateCellsRow;\n    });\n    return result;\n  }\n\n  _addKeysToCells(viewDataMap) {\n    var totalColumnCount = viewDataMap[0].length;\n    var {\n      currentViewDataMap: result\n    } = viewDataMap.reduce((_ref, row, rowIndex) => {\n      var {\n        allDayPanelsCount: allDayPanelsCount,\n        currentViewDataMap: currentViewDataMap\n      } = _ref;\n      var isAllDay = row[0].allDay;\n      var keyBase = (rowIndex - allDayPanelsCount) * totalColumnCount;\n      var currentAllDayPanelsCount = isAllDay ? allDayPanelsCount + 1 : allDayPanelsCount;\n      currentViewDataMap[rowIndex].forEach((cell, columnIndex) => {\n        cell.key = keyBase + columnIndex;\n      });\n      return {\n        allDayPanelsCount: currentAllDayPanelsCount,\n        currentViewDataMap: currentViewDataMap\n      };\n    }, {\n      allDayPanelsCount: 0,\n      currentViewDataMap: viewDataMap\n    });\n    return result;\n  }\n\n  generateViewDataMap(completeViewDataMap, options) {\n    var {\n      rowCount: rowCount,\n      startCellIndex: startCellIndex,\n      startRowIndex: startRowIndex,\n      cellCount: cellCount,\n      isVerticalGrouping: isVerticalGrouping,\n      isAllDayPanelVisible: isAllDayPanelVisible\n    } = options;\n\n    var sliceCells = (row, rowIndex, startIndex, count) => {\n      var sliceToIndex = void 0 !== count ? startIndex + count : void 0;\n      return row.slice(startIndex, sliceToIndex).map((cellData, columnIndex) => ({\n        cellData: cellData,\n        position: {\n          rowIndex: rowIndex,\n          columnIndex: columnIndex\n        }\n      }));\n    };\n\n    var correctedStartRowIndex = startRowIndex;\n    var allDayPanelMap = [];\n\n    if (this._isStandaloneAllDayPanel(isVerticalGrouping, isAllDayPanelVisible)) {\n      correctedStartRowIndex++;\n      allDayPanelMap = sliceCells(completeViewDataMap[0], 0, startCellIndex, cellCount);\n    }\n\n    var displayedRowCount = getDisplayedRowCount(rowCount, completeViewDataMap);\n    var dateTableMap = completeViewDataMap.slice(correctedStartRowIndex, correctedStartRowIndex + displayedRowCount).map((row, rowIndex) => sliceCells(row, rowIndex, startCellIndex, cellCount));\n    return {\n      allDayPanelMap: allDayPanelMap,\n      dateTableMap: dateTableMap\n    };\n  }\n\n  _isStandaloneAllDayPanel(isVerticalGrouping, isAllDayPanelVisible) {\n    return !isVerticalGrouping && isAllDayPanelVisible;\n  }\n\n  getViewDataFromMap(completeViewDataMap, viewDataMap, options) {\n    var {\n      topVirtualRowHeight: topVirtualRowHeight,\n      bottomVirtualRowHeight: bottomVirtualRowHeight,\n      leftVirtualCellWidth: leftVirtualCellWidth,\n      rightVirtualCellWidth: rightVirtualCellWidth,\n      cellCount: cellCount,\n      rowCount: rowCount,\n      startRowIndex: startRowIndex,\n      startCellIndex: startCellIndex,\n      isProvideVirtualCellsWidth: isProvideVirtualCellsWidth,\n      isGroupedAllDayPanel: isGroupedAllDayPanel,\n      isVerticalGrouping: isVerticalGrouping,\n      isAllDayPanelVisible: isAllDayPanelVisible\n    } = options;\n    var {\n      allDayPanelMap: allDayPanelMap,\n      dateTableMap: dateTableMap\n    } = viewDataMap;\n    var {\n      groupedData: groupedData\n    } = dateTableMap.reduce((_ref2, cellsRow) => {\n      var {\n        previousGroupIndex: previousGroupIndex,\n        groupedData: groupedData\n      } = _ref2;\n      var cellDataRow = cellsRow.map(_ref3 => {\n        var {\n          cellData: cellData\n        } = _ref3;\n        return cellData;\n      });\n      var firstCell = cellDataRow[0];\n      var isAllDayRow = firstCell.allDay;\n      var currentGroupIndex = firstCell.groupIndex;\n\n      if (currentGroupIndex !== previousGroupIndex) {\n        groupedData.push({\n          dateTable: [],\n          isGroupedAllDayPanel: getIsGroupedAllDayPanel(!!isAllDayRow, isVerticalGrouping),\n          groupIndex: currentGroupIndex,\n          key: getKeyByGroup(currentGroupIndex, isVerticalGrouping)\n        });\n      }\n\n      if (isAllDayRow) {\n        groupedData[groupedData.length - 1].allDayPanel = cellDataRow;\n      } else {\n        groupedData[groupedData.length - 1].dateTable.push({\n          cells: cellDataRow,\n          key: cellDataRow[0].key - startCellIndex\n        });\n      }\n\n      return {\n        groupedData: groupedData,\n        previousGroupIndex: currentGroupIndex\n      };\n    }, {\n      previousGroupIndex: -1,\n      groupedData: []\n    });\n\n    if (this._isStandaloneAllDayPanel(isVerticalGrouping, isAllDayPanelVisible)) {\n      groupedData[0].allDayPanel = allDayPanelMap.map(_ref4 => {\n        var {\n          cellData: cellData\n        } = _ref4;\n        return cellData;\n      });\n    }\n\n    var totalCellCount = getTotalCellCountByCompleteData(completeViewDataMap);\n    var totalRowCount = getTotalRowCountByCompleteData(completeViewDataMap);\n    var displayedCellCount = getDisplayedCellCount(cellCount, completeViewDataMap);\n    var displayedRowCount = getDisplayedRowCount(rowCount, completeViewDataMap);\n    return {\n      groupedData: groupedData,\n      topVirtualRowHeight: topVirtualRowHeight,\n      bottomVirtualRowHeight: bottomVirtualRowHeight,\n      leftVirtualCellWidth: isProvideVirtualCellsWidth ? leftVirtualCellWidth : void 0,\n      rightVirtualCellWidth: isProvideVirtualCellsWidth ? rightVirtualCellWidth : void 0,\n      isGroupedAllDayPanel: isGroupedAllDayPanel,\n      leftVirtualCellCount: startCellIndex,\n      rightVirtualCellCount: void 0 === cellCount ? 0 : totalCellCount - startCellIndex - displayedCellCount,\n      topVirtualRowCount: startRowIndex,\n      bottomVirtualRowCount: totalRowCount - startRowIndex - displayedRowCount\n    };\n  }\n\n  _generateViewCellsData(options, rowCount, cellCountInGroupRow) {\n    var viewCellsData = [];\n\n    for (var rowIndex = 0; rowIndex < rowCount; rowIndex += 1) {\n      viewCellsData.push(this._generateCellsRow(options, false, rowIndex, rowCount, cellCountInGroupRow));\n    }\n\n    return viewCellsData;\n  }\n\n  _generateAllDayPanelData(options, rowCount, columnCount) {\n    if (!options.isAllDayPanelVisible) {\n      return null;\n    }\n\n    return this._generateCellsRow(options, true, 0, rowCount, columnCount);\n  }\n\n  _generateCellsRow(options, allDay, rowIndex, rowCount, columnCount) {\n    var cellsRow = [];\n\n    for (var columnIndex = 0; columnIndex < columnCount; ++columnIndex) {\n      var cellDataValue = this.getCellData(rowIndex, columnIndex, options, allDay);\n      cellDataValue.index = rowIndex * columnCount + columnIndex;\n      cellDataValue.isFirstGroupCell = this._isFirstGroupCell(rowIndex, columnIndex, options, rowCount, columnCount);\n      cellDataValue.isLastGroupCell = this._isLastGroupCell(rowIndex, columnIndex, options, rowCount, columnCount);\n      cellsRow.push(cellDataValue);\n    }\n\n    return cellsRow;\n  }\n\n  getCellData(rowIndex, columnIndex, options, allDay) {\n    return allDay ? this.prepareAllDayCellData(options, rowIndex, columnIndex) : this.prepareCellData(options, rowIndex, columnIndex);\n  }\n\n  prepareCellData(options, rowIndex, columnIndex) {\n    var {\n      groups: groups,\n      startDayHour: startDayHour,\n      endDayHour: endDayHour,\n      interval: interval,\n      hoursInterval: hoursInterval\n    } = options;\n    var groupsList = getAllGroups(groups);\n    var startDate = this.getDateByCellIndices(options, rowIndex, columnIndex, this.getCellCountInDay(startDayHour, endDayHour, hoursInterval));\n    var endDate = this.calculateEndDate(startDate, interval, endDayHour);\n    var data = {\n      startDate: startDate,\n      endDate: endDate,\n      allDay: this.tableAllDay,\n      groupIndex: 0\n    };\n\n    if (groupsList.length > 0) {\n      data.groups = groupsList[0];\n    }\n\n    return data;\n  }\n\n  prepareAllDayCellData(options, rowIndex, columnIndex) {\n    var data = this.prepareCellData(options, rowIndex, columnIndex);\n    var startDate = dateUtils.trimTime(data.startDate);\n    return _extends({}, data, {\n      startDate: startDate,\n      endDate: startDate,\n      allDay: true\n    });\n  }\n\n  getDateByCellIndices(options, rowIndex, columnIndex, cellCountInDay) {\n    var startViewDate = options.startViewDate;\n    var {\n      startDayHour: startDayHour,\n      interval: interval,\n      firstDayOfWeek: firstDayOfWeek,\n      intervalCount: intervalCount\n    } = options;\n    var isStartViewDateDuringDST = startViewDate.getHours() !== Math.floor(startDayHour);\n\n    if (isStartViewDateDuringDST) {\n      var dateWithCorrectHours = getStartViewDateWithoutDST(startViewDate, startDayHour);\n      startViewDate = new Date(dateWithCorrectHours - dateUtils.dateToMilliseconds(\"day\"));\n    }\n\n    var columnCountBase = this.getCellCount(options);\n    var rowCountBase = this.getRowCount(options);\n\n    var cellIndex = this._calculateCellIndex(rowIndex, columnIndex, rowCountBase, columnCountBase);\n\n    var millisecondsOffset = this.getMillisecondsOffset(cellIndex, interval, cellCountInDay);\n    var offsetByCount = this.isWorkView ? this.getTimeOffsetByColumnIndex(columnIndex, this.getFirstDayOfWeek(firstDayOfWeek), columnCountBase, intervalCount) : 0;\n    var startViewDateTime = startViewDate.getTime();\n    var currentDate = new Date(startViewDateTime + millisecondsOffset + offsetByCount);\n    var timeZoneDifference = isStartViewDateDuringDST ? 0 : dateUtils.getTimezonesDifference(startViewDate, currentDate);\n    currentDate.setTime(currentDate.getTime() + timeZoneDifference);\n    return currentDate;\n  }\n\n  getMillisecondsOffset(cellIndex, interval, cellCountInDay) {\n    var dayIndex = Math.floor(cellIndex / cellCountInDay);\n    var realHiddenInterval = dayIndex * this.hiddenInterval;\n    return interval * cellIndex + realHiddenInterval;\n  }\n\n  getTimeOffsetByColumnIndex(columnIndex, firstDayOfWeek, columnCount, intervalCount) {\n    var firstDayOfWeekDiff = Math.max(0, firstDayOfWeek - 1);\n    var columnsInWeek = columnCount / intervalCount;\n    var weekendCount = Math.floor((columnIndex + firstDayOfWeekDiff) / columnsInWeek);\n    return DAY_MS * weekendCount * 2;\n  }\n\n  calculateEndDate(startDate, interval, endDayHour) {\n    var result = new Date(startDate);\n    result.setMilliseconds(result.getMilliseconds() + Math.round(interval));\n    return result;\n  }\n\n  _calculateCellIndex(rowIndex, columnIndex, rowCount, columnCount) {\n    return calculateCellIndex(rowIndex, columnIndex, rowCount);\n  }\n\n  generateGroupedDataMap(viewDataMap) {\n    var {\n      allDayPanelMap: allDayPanelMap,\n      dateTableMap: dateTableMap\n    } = viewDataMap;\n    var {\n      previousGroupedDataMap: dateTableGroupedMap\n    } = dateTableMap.reduce((previousOptions, cellsRow) => {\n      var {\n        previousGroupedDataMap: previousGroupedDataMap,\n        previousRowIndex: previousRowIndex,\n        previousGroupIndex: previousGroupIndex\n      } = previousOptions;\n      var {\n        groupIndex: currentGroupIndex\n      } = cellsRow[0].cellData;\n      var currentRowIndex = currentGroupIndex === previousGroupIndex ? previousRowIndex + 1 : 0;\n      cellsRow.forEach(cell => {\n        var {\n          groupIndex: groupIndex\n        } = cell.cellData;\n\n        if (!previousGroupedDataMap[groupIndex]) {\n          previousGroupedDataMap[groupIndex] = [];\n        }\n\n        if (!previousGroupedDataMap[groupIndex][currentRowIndex]) {\n          previousGroupedDataMap[groupIndex][currentRowIndex] = [];\n        }\n\n        previousGroupedDataMap[groupIndex][currentRowIndex].push(cell);\n      });\n      return {\n        previousGroupedDataMap: previousGroupedDataMap,\n        previousRowIndex: currentRowIndex,\n        previousGroupIndex: currentGroupIndex\n      };\n    }, {\n      previousGroupedDataMap: [],\n      previousRowIndex: -1,\n      previousGroupIndex: -1\n    });\n    var allDayPanelGroupedMap = [];\n    null === allDayPanelMap || void 0 === allDayPanelMap ? void 0 : allDayPanelMap.forEach(cell => {\n      var {\n        groupIndex: groupIndex\n      } = cell.cellData;\n\n      if (!allDayPanelGroupedMap[groupIndex]) {\n        allDayPanelGroupedMap[groupIndex] = [];\n      }\n\n      allDayPanelGroupedMap[groupIndex].push(cell);\n    });\n    return {\n      allDayPanelGroupedMap: allDayPanelGroupedMap,\n      dateTableGroupedMap: dateTableGroupedMap\n    };\n  }\n\n  _isFirstGroupCell(rowIndex, columnIndex, options, rowCount, columnCount) {\n    var {\n      groupOrientation: groupOrientation,\n      groups: groups,\n      isGroupedByDate: isGroupedByDate\n    } = options;\n    var groupCount = getGroupCount(groups);\n\n    if (isGroupedByDate) {\n      return columnIndex % groupCount === 0;\n    }\n\n    if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\n      return columnIndex % columnCount === 0;\n    }\n\n    return rowIndex % rowCount === 0;\n  }\n\n  _isLastGroupCell(rowIndex, columnIndex, options, rowCount, columnCount) {\n    var {\n      groupOrientation: groupOrientation,\n      groups: groups,\n      isGroupedByDate: isGroupedByDate\n    } = options;\n    var groupCount = getGroupCount(groups);\n\n    if (isGroupedByDate) {\n      return (columnIndex + 1) % groupCount === 0;\n    }\n\n    if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\n      return (columnIndex + 1) % columnCount === 0;\n    }\n\n    return (rowIndex + 1) % rowCount === 0;\n  }\n\n  markSelectedAndFocusedCells(viewDataMap, renderOptions) {\n    var {\n      selectedCells: selectedCells,\n      focusedCell: focusedCell\n    } = renderOptions;\n\n    if (!selectedCells && !focusedCell) {\n      return viewDataMap;\n    }\n\n    var {\n      allDayPanelMap: allDayPanelMap,\n      dateTableMap: dateTableMap\n    } = viewDataMap;\n    var nextDateTableMap = dateTableMap.map(row => this._markSelectedAndFocusedCellsInRow(row, selectedCells, focusedCell));\n\n    var nextAllDayMap = this._markSelectedAndFocusedCellsInRow(allDayPanelMap, selectedCells, focusedCell);\n\n    return {\n      allDayPanelMap: nextAllDayMap,\n      dateTableMap: nextDateTableMap\n    };\n  }\n\n  _markSelectedAndFocusedCellsInRow(dataRow, selectedCells, focusedCell) {\n    return dataRow.map(cell => {\n      var {\n        index: index,\n        groupIndex: groupIndex,\n        allDay: allDay,\n        startDate: startDate\n      } = cell.cellData;\n      var indexInSelectedCells = selectedCells.findIndex(_ref5 => {\n        var {\n          index: selectedCellIndex,\n          groupIndex: selectedCellGroupIndex,\n          allDay: selectedCellAllDay,\n          startDate: selectedCellStartDate\n        } = _ref5;\n        return groupIndex === selectedCellGroupIndex && (index === selectedCellIndex || void 0 === selectedCellIndex && startDate.getTime() === selectedCellStartDate.getTime()) && !!allDay === !!selectedCellAllDay;\n      });\n      var isFocused = !!focusedCell && index === focusedCell.cellData.index && groupIndex === focusedCell.cellData.groupIndex && allDay === focusedCell.cellData.allDay;\n\n      if (!isFocused && -1 === indexInSelectedCells) {\n        return cell;\n      }\n\n      return _extends({}, cell, {\n        cellData: _extends({}, cell.cellData, {\n          isSelected: indexInSelectedCells > -1,\n          isFocused: isFocused\n        })\n      });\n    });\n  }\n\n  getInterval(hoursInterval) {\n    return hoursInterval * HOUR_MS;\n  }\n\n  _getIntervalDuration(intervalCount) {\n    return dateUtils.dateToMilliseconds(\"day\") * intervalCount;\n  }\n\n  _setVisibilityDates() {}\n\n  getCellCountInDay(startDayHour, endDayHour, hoursInterval) {\n    var result = calculateDayDuration(startDayHour, endDayHour) / hoursInterval;\n    return Math.ceil(result);\n  }\n\n  getCellCount(options) {\n    var {\n      intervalCount: intervalCount,\n      viewType: viewType,\n      startDayHour: startDayHour,\n      endDayHour: endDayHour,\n      hoursInterval: hoursInterval\n    } = options;\n    var cellCountInDay = this.getCellCountInDay(startDayHour, endDayHour, hoursInterval);\n    var columnCountInDay = isHorizontalView(viewType) ? cellCountInDay : 1;\n    return this.daysInInterval * intervalCount * columnCountInDay;\n  }\n\n  getRowCount(options) {\n    var {\n      viewType: viewType,\n      startDayHour: startDayHour,\n      endDayHour: endDayHour,\n      hoursInterval: hoursInterval\n    } = options;\n    var cellCountInDay = this.getCellCountInDay(startDayHour, endDayHour, hoursInterval);\n    var rowCountInDay = !isHorizontalView(viewType) ? cellCountInDay : 1;\n    return rowCountInDay;\n  }\n\n  setHiddenInterval(startDayHour, endDayHour, hoursInterval) {\n    this.hiddenInterval = DAY_MS - this.getVisibleDayDuration(startDayHour, endDayHour, hoursInterval);\n  }\n\n  getVisibleDayDuration(startDayHour, endDayHour, hoursInterval) {\n    var cellCountInDay = this.getCellCountInDay(startDayHour, endDayHour, hoursInterval);\n    return hoursInterval * cellCountInDay * HOUR_MS;\n  }\n\n  getFirstDayOfWeek(firstDayOfWeekOption) {\n    return firstDayOfWeekOption;\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Zoran/source/repos/TransportApp/TransportLog-basic/node_modules/devextreme/esm/ui/scheduler/workspaces/view_model/view_data_generator.js"],"names":["_extends","dateUtils","HORIZONTAL_GROUP_ORIENTATION","getAllGroups","getGroupCount","calculateCellIndex","calculateDayDuration","isHorizontalView","getStartViewDateWithoutDST","getDisplayedRowCount","getTotalCellCountByCompleteData","getTotalRowCountByCompleteData","getDisplayedCellCount","getIsGroupedAllDayPanel","getKeyByGroup","HOUR_MS","dateToMilliseconds","DAY_MS","ViewDataGenerator","daysInInterval","isWorkView","tableAllDay","isSkippedDate","getStartViewDate","options","_calculateStartViewDate","getCompleteViewDataMap","groups","isGroupedByDate","isHorizontalGrouping","isVerticalGrouping","intervalCount","currentDate","viewType","startDayHour","endDayHour","hoursInterval","_setVisibilityDates","setHiddenInterval","groupsList","cellCountInGroupRow","getCellCount","rowCountInGroup","getRowCount","viewDataMap","allDayPanelData","_generateAllDayPanelData","viewCellsData","_generateViewCellsData","push","_transformViewDataMapForHorizontalGrouping","_transformViewDataMapForVerticalGrouping","_transformViewDataMapForGroupingByDate","completeViewDataMap","_addKeysToCells","result","map","row","slice","forEach","index","groupIndex","rowIndex","nextGroupRow","cellData","nextGroupMap","cellsRow","nextRow","correctedGroupList","correctedGroupCount","length","groupedByDateCellsRow","reduce","currentRow","cell","rowWithCurrentCell","isFirstGroupCell","isLastGroupCell","totalColumnCount","currentViewDataMap","_ref","allDayPanelsCount","isAllDay","allDay","keyBase","currentAllDayPanelsCount","columnIndex","key","generateViewDataMap","rowCount","startCellIndex","startRowIndex","cellCount","isAllDayPanelVisible","sliceCells","startIndex","count","sliceToIndex","position","correctedStartRowIndex","allDayPanelMap","_isStandaloneAllDayPanel","displayedRowCount","dateTableMap","getViewDataFromMap","topVirtualRowHeight","bottomVirtualRowHeight","leftVirtualCellWidth","rightVirtualCellWidth","isProvideVirtualCellsWidth","isGroupedAllDayPanel","groupedData","_ref2","previousGroupIndex","cellDataRow","_ref3","firstCell","isAllDayRow","currentGroupIndex","dateTable","allDayPanel","cells","_ref4","totalCellCount","totalRowCount","displayedCellCount","leftVirtualCellCount","rightVirtualCellCount","topVirtualRowCount","bottomVirtualRowCount","_generateCellsRow","columnCount","cellDataValue","getCellData","_isFirstGroupCell","_isLastGroupCell","prepareAllDayCellData","prepareCellData","interval","startDate","getDateByCellIndices","getCellCountInDay","endDate","calculateEndDate","data","trimTime","cellCountInDay","startViewDate","firstDayOfWeek","isStartViewDateDuringDST","getHours","Math","floor","dateWithCorrectHours","Date","columnCountBase","rowCountBase","cellIndex","_calculateCellIndex","millisecondsOffset","getMillisecondsOffset","offsetByCount","getTimeOffsetByColumnIndex","getFirstDayOfWeek","startViewDateTime","getTime","timeZoneDifference","getTimezonesDifference","setTime","dayIndex","realHiddenInterval","hiddenInterval","firstDayOfWeekDiff","max","columnsInWeek","weekendCount","setMilliseconds","getMilliseconds","round","generateGroupedDataMap","previousGroupedDataMap","dateTableGroupedMap","previousOptions","previousRowIndex","currentRowIndex","allDayPanelGroupedMap","groupOrientation","groupCount","markSelectedAndFocusedCells","renderOptions","selectedCells","focusedCell","nextDateTableMap","_markSelectedAndFocusedCellsInRow","nextAllDayMap","dataRow","indexInSelectedCells","findIndex","_ref5","selectedCellIndex","selectedCellGroupIndex","selectedCellAllDay","selectedCellStartDate","isFocused","isSelected","getInterval","_getIntervalDuration","ceil","columnCountInDay","rowCountInDay","getVisibleDayDuration","firstDayOfWeekOption"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/view_model/view_data_generator.js)\r\n * Version: 22.1.6\r\n * Build date: Tue Oct 18 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\r\nimport dateUtils from \"../../../../core/utils/date\";\r\nimport {\r\n    HORIZONTAL_GROUP_ORIENTATION\r\n} from \"../../constants\";\r\nimport {\r\n    getAllGroups,\r\n    getGroupCount\r\n} from \"../../resources/utils\";\r\nimport {\r\n    calculateCellIndex,\r\n    calculateDayDuration,\r\n    isHorizontalView,\r\n    getStartViewDateWithoutDST,\r\n    getDisplayedRowCount,\r\n    getTotalCellCountByCompleteData,\r\n    getTotalRowCountByCompleteData,\r\n    getDisplayedCellCount\r\n} from \"../../../../renovation/ui/scheduler/view_model/to_test/views/utils/base\";\r\nimport {\r\n    getIsGroupedAllDayPanel,\r\n    getKeyByGroup\r\n} from \"../../../../renovation/ui/scheduler/workspaces/utils\";\r\nvar HOUR_MS = dateUtils.dateToMilliseconds(\"hour\");\r\nvar DAY_MS = dateUtils.dateToMilliseconds(\"day\");\r\nexport class ViewDataGenerator {\r\n    get daysInInterval() {\r\n        return 1\r\n    }\r\n    get isWorkView() {\r\n        return false\r\n    }\r\n    get tableAllDay() {\r\n        return false\r\n    }\r\n    isSkippedDate() {\r\n        return false\r\n    }\r\n    getStartViewDate(options) {\r\n        return this._calculateStartViewDate(options)\r\n    }\r\n    getCompleteViewDataMap(options) {\r\n        var {\r\n            groups: groups,\r\n            isGroupedByDate: isGroupedByDate,\r\n            isHorizontalGrouping: isHorizontalGrouping,\r\n            isVerticalGrouping: isVerticalGrouping,\r\n            intervalCount: intervalCount,\r\n            currentDate: currentDate,\r\n            viewType: viewType,\r\n            startDayHour: startDayHour,\r\n            endDayHour: endDayHour,\r\n            hoursInterval: hoursInterval\r\n        } = options;\r\n        this._setVisibilityDates(options);\r\n        this.setHiddenInterval(startDayHour, endDayHour, hoursInterval);\r\n        var groupsList = getAllGroups(groups);\r\n        var cellCountInGroupRow = this.getCellCount({\r\n            intervalCount: intervalCount,\r\n            currentDate: currentDate,\r\n            viewType: viewType,\r\n            startDayHour: startDayHour,\r\n            endDayHour: endDayHour,\r\n            hoursInterval: hoursInterval\r\n        });\r\n        var rowCountInGroup = this.getRowCount({\r\n            intervalCount: intervalCount,\r\n            currentDate: currentDate,\r\n            viewType: viewType,\r\n            hoursInterval: hoursInterval,\r\n            startDayHour: startDayHour,\r\n            endDayHour: endDayHour\r\n        });\r\n        var viewDataMap = [];\r\n        var allDayPanelData = this._generateAllDayPanelData(options, rowCountInGroup, cellCountInGroupRow);\r\n        var viewCellsData = this._generateViewCellsData(options, rowCountInGroup, cellCountInGroupRow);\r\n        allDayPanelData && viewDataMap.push(allDayPanelData);\r\n        viewDataMap.push(...viewCellsData);\r\n        if (isHorizontalGrouping && !isGroupedByDate) {\r\n            viewDataMap = this._transformViewDataMapForHorizontalGrouping(viewDataMap, groupsList)\r\n        }\r\n        if (isVerticalGrouping) {\r\n            viewDataMap = this._transformViewDataMapForVerticalGrouping(viewDataMap, groupsList)\r\n        }\r\n        if (isGroupedByDate) {\r\n            viewDataMap = this._transformViewDataMapForGroupingByDate(viewDataMap, groupsList)\r\n        }\r\n        var completeViewDataMap = this._addKeysToCells(viewDataMap);\r\n        return completeViewDataMap\r\n    }\r\n    _transformViewDataMapForHorizontalGrouping(viewDataMap, groupsList) {\r\n        var result = viewDataMap.map(row => row.slice());\r\n        groupsList.slice(1).forEach((groups, index) => {\r\n            var groupIndex = index + 1;\r\n            viewDataMap.forEach((row, rowIndex) => {\r\n                var nextGroupRow = row.map(cellData => _extends({}, cellData, {\r\n                    groups: groups,\r\n                    groupIndex: groupIndex\r\n                }));\r\n                result[rowIndex].push(...nextGroupRow)\r\n            })\r\n        });\r\n        return result\r\n    }\r\n    _transformViewDataMapForVerticalGrouping(viewDataMap, groupsList) {\r\n        var result = viewDataMap.map(row => row.slice());\r\n        groupsList.slice(1).forEach((groups, index) => {\r\n            var groupIndex = index + 1;\r\n            var nextGroupMap = viewDataMap.map(cellsRow => {\r\n                var nextRow = cellsRow.map(cellData => _extends({}, cellData, {\r\n                    groupIndex: groupIndex,\r\n                    groups: groups\r\n                }));\r\n                return nextRow\r\n            });\r\n            result.push(...nextGroupMap)\r\n        });\r\n        return result\r\n    }\r\n    _transformViewDataMapForGroupingByDate(viewDataMap, groupsList) {\r\n        var correctedGroupList = groupsList.slice(1);\r\n        var correctedGroupCount = correctedGroupList.length;\r\n        var result = viewDataMap.map(cellsRow => {\r\n            var groupedByDateCellsRow = cellsRow.reduce((currentRow, cell) => {\r\n                var rowWithCurrentCell = [...currentRow, _extends({}, cell, {\r\n                    isFirstGroupCell: true,\r\n                    isLastGroupCell: 0 === correctedGroupCount\r\n                }), ...correctedGroupList.map((groups, index) => _extends({}, cell, {\r\n                    groups: groups,\r\n                    groupIndex: index + 1,\r\n                    isFirstGroupCell: false,\r\n                    isLastGroupCell: index === correctedGroupCount - 1\r\n                }))];\r\n                return rowWithCurrentCell\r\n            }, []);\r\n            return groupedByDateCellsRow\r\n        });\r\n        return result\r\n    }\r\n    _addKeysToCells(viewDataMap) {\r\n        var totalColumnCount = viewDataMap[0].length;\r\n        var {\r\n            currentViewDataMap: result\r\n        } = viewDataMap.reduce((_ref, row, rowIndex) => {\r\n            var {\r\n                allDayPanelsCount: allDayPanelsCount,\r\n                currentViewDataMap: currentViewDataMap\r\n            } = _ref;\r\n            var isAllDay = row[0].allDay;\r\n            var keyBase = (rowIndex - allDayPanelsCount) * totalColumnCount;\r\n            var currentAllDayPanelsCount = isAllDay ? allDayPanelsCount + 1 : allDayPanelsCount;\r\n            currentViewDataMap[rowIndex].forEach((cell, columnIndex) => {\r\n                cell.key = keyBase + columnIndex\r\n            });\r\n            return {\r\n                allDayPanelsCount: currentAllDayPanelsCount,\r\n                currentViewDataMap: currentViewDataMap\r\n            }\r\n        }, {\r\n            allDayPanelsCount: 0,\r\n            currentViewDataMap: viewDataMap\r\n        });\r\n        return result\r\n    }\r\n    generateViewDataMap(completeViewDataMap, options) {\r\n        var {\r\n            rowCount: rowCount,\r\n            startCellIndex: startCellIndex,\r\n            startRowIndex: startRowIndex,\r\n            cellCount: cellCount,\r\n            isVerticalGrouping: isVerticalGrouping,\r\n            isAllDayPanelVisible: isAllDayPanelVisible\r\n        } = options;\r\n        var sliceCells = (row, rowIndex, startIndex, count) => {\r\n            var sliceToIndex = void 0 !== count ? startIndex + count : void 0;\r\n            return row.slice(startIndex, sliceToIndex).map((cellData, columnIndex) => ({\r\n                cellData: cellData,\r\n                position: {\r\n                    rowIndex: rowIndex,\r\n                    columnIndex: columnIndex\r\n                }\r\n            }))\r\n        };\r\n        var correctedStartRowIndex = startRowIndex;\r\n        var allDayPanelMap = [];\r\n        if (this._isStandaloneAllDayPanel(isVerticalGrouping, isAllDayPanelVisible)) {\r\n            correctedStartRowIndex++;\r\n            allDayPanelMap = sliceCells(completeViewDataMap[0], 0, startCellIndex, cellCount)\r\n        }\r\n        var displayedRowCount = getDisplayedRowCount(rowCount, completeViewDataMap);\r\n        var dateTableMap = completeViewDataMap.slice(correctedStartRowIndex, correctedStartRowIndex + displayedRowCount).map((row, rowIndex) => sliceCells(row, rowIndex, startCellIndex, cellCount));\r\n        return {\r\n            allDayPanelMap: allDayPanelMap,\r\n            dateTableMap: dateTableMap\r\n        }\r\n    }\r\n    _isStandaloneAllDayPanel(isVerticalGrouping, isAllDayPanelVisible) {\r\n        return !isVerticalGrouping && isAllDayPanelVisible\r\n    }\r\n    getViewDataFromMap(completeViewDataMap, viewDataMap, options) {\r\n        var {\r\n            topVirtualRowHeight: topVirtualRowHeight,\r\n            bottomVirtualRowHeight: bottomVirtualRowHeight,\r\n            leftVirtualCellWidth: leftVirtualCellWidth,\r\n            rightVirtualCellWidth: rightVirtualCellWidth,\r\n            cellCount: cellCount,\r\n            rowCount: rowCount,\r\n            startRowIndex: startRowIndex,\r\n            startCellIndex: startCellIndex,\r\n            isProvideVirtualCellsWidth: isProvideVirtualCellsWidth,\r\n            isGroupedAllDayPanel: isGroupedAllDayPanel,\r\n            isVerticalGrouping: isVerticalGrouping,\r\n            isAllDayPanelVisible: isAllDayPanelVisible\r\n        } = options;\r\n        var {\r\n            allDayPanelMap: allDayPanelMap,\r\n            dateTableMap: dateTableMap\r\n        } = viewDataMap;\r\n        var {\r\n            groupedData: groupedData\r\n        } = dateTableMap.reduce((_ref2, cellsRow) => {\r\n            var {\r\n                previousGroupIndex: previousGroupIndex,\r\n                groupedData: groupedData\r\n            } = _ref2;\r\n            var cellDataRow = cellsRow.map(_ref3 => {\r\n                var {\r\n                    cellData: cellData\r\n                } = _ref3;\r\n                return cellData\r\n            });\r\n            var firstCell = cellDataRow[0];\r\n            var isAllDayRow = firstCell.allDay;\r\n            var currentGroupIndex = firstCell.groupIndex;\r\n            if (currentGroupIndex !== previousGroupIndex) {\r\n                groupedData.push({\r\n                    dateTable: [],\r\n                    isGroupedAllDayPanel: getIsGroupedAllDayPanel(!!isAllDayRow, isVerticalGrouping),\r\n                    groupIndex: currentGroupIndex,\r\n                    key: getKeyByGroup(currentGroupIndex, isVerticalGrouping)\r\n                })\r\n            }\r\n            if (isAllDayRow) {\r\n                groupedData[groupedData.length - 1].allDayPanel = cellDataRow\r\n            } else {\r\n                groupedData[groupedData.length - 1].dateTable.push({\r\n                    cells: cellDataRow,\r\n                    key: cellDataRow[0].key - startCellIndex\r\n                })\r\n            }\r\n            return {\r\n                groupedData: groupedData,\r\n                previousGroupIndex: currentGroupIndex\r\n            }\r\n        }, {\r\n            previousGroupIndex: -1,\r\n            groupedData: []\r\n        });\r\n        if (this._isStandaloneAllDayPanel(isVerticalGrouping, isAllDayPanelVisible)) {\r\n            groupedData[0].allDayPanel = allDayPanelMap.map(_ref4 => {\r\n                var {\r\n                    cellData: cellData\r\n                } = _ref4;\r\n                return cellData\r\n            })\r\n        }\r\n        var totalCellCount = getTotalCellCountByCompleteData(completeViewDataMap);\r\n        var totalRowCount = getTotalRowCountByCompleteData(completeViewDataMap);\r\n        var displayedCellCount = getDisplayedCellCount(cellCount, completeViewDataMap);\r\n        var displayedRowCount = getDisplayedRowCount(rowCount, completeViewDataMap);\r\n        return {\r\n            groupedData: groupedData,\r\n            topVirtualRowHeight: topVirtualRowHeight,\r\n            bottomVirtualRowHeight: bottomVirtualRowHeight,\r\n            leftVirtualCellWidth: isProvideVirtualCellsWidth ? leftVirtualCellWidth : void 0,\r\n            rightVirtualCellWidth: isProvideVirtualCellsWidth ? rightVirtualCellWidth : void 0,\r\n            isGroupedAllDayPanel: isGroupedAllDayPanel,\r\n            leftVirtualCellCount: startCellIndex,\r\n            rightVirtualCellCount: void 0 === cellCount ? 0 : totalCellCount - startCellIndex - displayedCellCount,\r\n            topVirtualRowCount: startRowIndex,\r\n            bottomVirtualRowCount: totalRowCount - startRowIndex - displayedRowCount\r\n        }\r\n    }\r\n    _generateViewCellsData(options, rowCount, cellCountInGroupRow) {\r\n        var viewCellsData = [];\r\n        for (var rowIndex = 0; rowIndex < rowCount; rowIndex += 1) {\r\n            viewCellsData.push(this._generateCellsRow(options, false, rowIndex, rowCount, cellCountInGroupRow))\r\n        }\r\n        return viewCellsData\r\n    }\r\n    _generateAllDayPanelData(options, rowCount, columnCount) {\r\n        if (!options.isAllDayPanelVisible) {\r\n            return null\r\n        }\r\n        return this._generateCellsRow(options, true, 0, rowCount, columnCount)\r\n    }\r\n    _generateCellsRow(options, allDay, rowIndex, rowCount, columnCount) {\r\n        var cellsRow = [];\r\n        for (var columnIndex = 0; columnIndex < columnCount; ++columnIndex) {\r\n            var cellDataValue = this.getCellData(rowIndex, columnIndex, options, allDay);\r\n            cellDataValue.index = rowIndex * columnCount + columnIndex;\r\n            cellDataValue.isFirstGroupCell = this._isFirstGroupCell(rowIndex, columnIndex, options, rowCount, columnCount);\r\n            cellDataValue.isLastGroupCell = this._isLastGroupCell(rowIndex, columnIndex, options, rowCount, columnCount);\r\n            cellsRow.push(cellDataValue)\r\n        }\r\n        return cellsRow\r\n    }\r\n    getCellData(rowIndex, columnIndex, options, allDay) {\r\n        return allDay ? this.prepareAllDayCellData(options, rowIndex, columnIndex) : this.prepareCellData(options, rowIndex, columnIndex)\r\n    }\r\n    prepareCellData(options, rowIndex, columnIndex) {\r\n        var {\r\n            groups: groups,\r\n            startDayHour: startDayHour,\r\n            endDayHour: endDayHour,\r\n            interval: interval,\r\n            hoursInterval: hoursInterval\r\n        } = options;\r\n        var groupsList = getAllGroups(groups);\r\n        var startDate = this.getDateByCellIndices(options, rowIndex, columnIndex, this.getCellCountInDay(startDayHour, endDayHour, hoursInterval));\r\n        var endDate = this.calculateEndDate(startDate, interval, endDayHour);\r\n        var data = {\r\n            startDate: startDate,\r\n            endDate: endDate,\r\n            allDay: this.tableAllDay,\r\n            groupIndex: 0\r\n        };\r\n        if (groupsList.length > 0) {\r\n            data.groups = groupsList[0]\r\n        }\r\n        return data\r\n    }\r\n    prepareAllDayCellData(options, rowIndex, columnIndex) {\r\n        var data = this.prepareCellData(options, rowIndex, columnIndex);\r\n        var startDate = dateUtils.trimTime(data.startDate);\r\n        return _extends({}, data, {\r\n            startDate: startDate,\r\n            endDate: startDate,\r\n            allDay: true\r\n        })\r\n    }\r\n    getDateByCellIndices(options, rowIndex, columnIndex, cellCountInDay) {\r\n        var startViewDate = options.startViewDate;\r\n        var {\r\n            startDayHour: startDayHour,\r\n            interval: interval,\r\n            firstDayOfWeek: firstDayOfWeek,\r\n            intervalCount: intervalCount\r\n        } = options;\r\n        var isStartViewDateDuringDST = startViewDate.getHours() !== Math.floor(startDayHour);\r\n        if (isStartViewDateDuringDST) {\r\n            var dateWithCorrectHours = getStartViewDateWithoutDST(startViewDate, startDayHour);\r\n            startViewDate = new Date(dateWithCorrectHours - dateUtils.dateToMilliseconds(\"day\"))\r\n        }\r\n        var columnCountBase = this.getCellCount(options);\r\n        var rowCountBase = this.getRowCount(options);\r\n        var cellIndex = this._calculateCellIndex(rowIndex, columnIndex, rowCountBase, columnCountBase);\r\n        var millisecondsOffset = this.getMillisecondsOffset(cellIndex, interval, cellCountInDay);\r\n        var offsetByCount = this.isWorkView ? this.getTimeOffsetByColumnIndex(columnIndex, this.getFirstDayOfWeek(firstDayOfWeek), columnCountBase, intervalCount) : 0;\r\n        var startViewDateTime = startViewDate.getTime();\r\n        var currentDate = new Date(startViewDateTime + millisecondsOffset + offsetByCount);\r\n        var timeZoneDifference = isStartViewDateDuringDST ? 0 : dateUtils.getTimezonesDifference(startViewDate, currentDate);\r\n        currentDate.setTime(currentDate.getTime() + timeZoneDifference);\r\n        return currentDate\r\n    }\r\n    getMillisecondsOffset(cellIndex, interval, cellCountInDay) {\r\n        var dayIndex = Math.floor(cellIndex / cellCountInDay);\r\n        var realHiddenInterval = dayIndex * this.hiddenInterval;\r\n        return interval * cellIndex + realHiddenInterval\r\n    }\r\n    getTimeOffsetByColumnIndex(columnIndex, firstDayOfWeek, columnCount, intervalCount) {\r\n        var firstDayOfWeekDiff = Math.max(0, firstDayOfWeek - 1);\r\n        var columnsInWeek = columnCount / intervalCount;\r\n        var weekendCount = Math.floor((columnIndex + firstDayOfWeekDiff) / columnsInWeek);\r\n        return DAY_MS * weekendCount * 2\r\n    }\r\n    calculateEndDate(startDate, interval, endDayHour) {\r\n        var result = new Date(startDate);\r\n        result.setMilliseconds(result.getMilliseconds() + Math.round(interval));\r\n        return result\r\n    }\r\n    _calculateCellIndex(rowIndex, columnIndex, rowCount, columnCount) {\r\n        return calculateCellIndex(rowIndex, columnIndex, rowCount)\r\n    }\r\n    generateGroupedDataMap(viewDataMap) {\r\n        var {\r\n            allDayPanelMap: allDayPanelMap,\r\n            dateTableMap: dateTableMap\r\n        } = viewDataMap;\r\n        var {\r\n            previousGroupedDataMap: dateTableGroupedMap\r\n        } = dateTableMap.reduce((previousOptions, cellsRow) => {\r\n            var {\r\n                previousGroupedDataMap: previousGroupedDataMap,\r\n                previousRowIndex: previousRowIndex,\r\n                previousGroupIndex: previousGroupIndex\r\n            } = previousOptions;\r\n            var {\r\n                groupIndex: currentGroupIndex\r\n            } = cellsRow[0].cellData;\r\n            var currentRowIndex = currentGroupIndex === previousGroupIndex ? previousRowIndex + 1 : 0;\r\n            cellsRow.forEach(cell => {\r\n                var {\r\n                    groupIndex: groupIndex\r\n                } = cell.cellData;\r\n                if (!previousGroupedDataMap[groupIndex]) {\r\n                    previousGroupedDataMap[groupIndex] = []\r\n                }\r\n                if (!previousGroupedDataMap[groupIndex][currentRowIndex]) {\r\n                    previousGroupedDataMap[groupIndex][currentRowIndex] = []\r\n                }\r\n                previousGroupedDataMap[groupIndex][currentRowIndex].push(cell)\r\n            });\r\n            return {\r\n                previousGroupedDataMap: previousGroupedDataMap,\r\n                previousRowIndex: currentRowIndex,\r\n                previousGroupIndex: currentGroupIndex\r\n            }\r\n        }, {\r\n            previousGroupedDataMap: [],\r\n            previousRowIndex: -1,\r\n            previousGroupIndex: -1\r\n        });\r\n        var allDayPanelGroupedMap = [];\r\n        null === allDayPanelMap || void 0 === allDayPanelMap ? void 0 : allDayPanelMap.forEach(cell => {\r\n            var {\r\n                groupIndex: groupIndex\r\n            } = cell.cellData;\r\n            if (!allDayPanelGroupedMap[groupIndex]) {\r\n                allDayPanelGroupedMap[groupIndex] = []\r\n            }\r\n            allDayPanelGroupedMap[groupIndex].push(cell)\r\n        });\r\n        return {\r\n            allDayPanelGroupedMap: allDayPanelGroupedMap,\r\n            dateTableGroupedMap: dateTableGroupedMap\r\n        }\r\n    }\r\n    _isFirstGroupCell(rowIndex, columnIndex, options, rowCount, columnCount) {\r\n        var {\r\n            groupOrientation: groupOrientation,\r\n            groups: groups,\r\n            isGroupedByDate: isGroupedByDate\r\n        } = options;\r\n        var groupCount = getGroupCount(groups);\r\n        if (isGroupedByDate) {\r\n            return columnIndex % groupCount === 0\r\n        }\r\n        if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\r\n            return columnIndex % columnCount === 0\r\n        }\r\n        return rowIndex % rowCount === 0\r\n    }\r\n    _isLastGroupCell(rowIndex, columnIndex, options, rowCount, columnCount) {\r\n        var {\r\n            groupOrientation: groupOrientation,\r\n            groups: groups,\r\n            isGroupedByDate: isGroupedByDate\r\n        } = options;\r\n        var groupCount = getGroupCount(groups);\r\n        if (isGroupedByDate) {\r\n            return (columnIndex + 1) % groupCount === 0\r\n        }\r\n        if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\r\n            return (columnIndex + 1) % columnCount === 0\r\n        }\r\n        return (rowIndex + 1) % rowCount === 0\r\n    }\r\n    markSelectedAndFocusedCells(viewDataMap, renderOptions) {\r\n        var {\r\n            selectedCells: selectedCells,\r\n            focusedCell: focusedCell\r\n        } = renderOptions;\r\n        if (!selectedCells && !focusedCell) {\r\n            return viewDataMap\r\n        }\r\n        var {\r\n            allDayPanelMap: allDayPanelMap,\r\n            dateTableMap: dateTableMap\r\n        } = viewDataMap;\r\n        var nextDateTableMap = dateTableMap.map(row => this._markSelectedAndFocusedCellsInRow(row, selectedCells, focusedCell));\r\n        var nextAllDayMap = this._markSelectedAndFocusedCellsInRow(allDayPanelMap, selectedCells, focusedCell);\r\n        return {\r\n            allDayPanelMap: nextAllDayMap,\r\n            dateTableMap: nextDateTableMap\r\n        }\r\n    }\r\n    _markSelectedAndFocusedCellsInRow(dataRow, selectedCells, focusedCell) {\r\n        return dataRow.map(cell => {\r\n            var {\r\n                index: index,\r\n                groupIndex: groupIndex,\r\n                allDay: allDay,\r\n                startDate: startDate\r\n            } = cell.cellData;\r\n            var indexInSelectedCells = selectedCells.findIndex(_ref5 => {\r\n                var {\r\n                    index: selectedCellIndex,\r\n                    groupIndex: selectedCellGroupIndex,\r\n                    allDay: selectedCellAllDay,\r\n                    startDate: selectedCellStartDate\r\n                } = _ref5;\r\n                return groupIndex === selectedCellGroupIndex && (index === selectedCellIndex || void 0 === selectedCellIndex && startDate.getTime() === selectedCellStartDate.getTime()) && !!allDay === !!selectedCellAllDay\r\n            });\r\n            var isFocused = !!focusedCell && index === focusedCell.cellData.index && groupIndex === focusedCell.cellData.groupIndex && allDay === focusedCell.cellData.allDay;\r\n            if (!isFocused && -1 === indexInSelectedCells) {\r\n                return cell\r\n            }\r\n            return _extends({}, cell, {\r\n                cellData: _extends({}, cell.cellData, {\r\n                    isSelected: indexInSelectedCells > -1,\r\n                    isFocused: isFocused\r\n                })\r\n            })\r\n        })\r\n    }\r\n    getInterval(hoursInterval) {\r\n        return hoursInterval * HOUR_MS\r\n    }\r\n    _getIntervalDuration(intervalCount) {\r\n        return dateUtils.dateToMilliseconds(\"day\") * intervalCount\r\n    }\r\n    _setVisibilityDates() {}\r\n    getCellCountInDay(startDayHour, endDayHour, hoursInterval) {\r\n        var result = calculateDayDuration(startDayHour, endDayHour) / hoursInterval;\r\n        return Math.ceil(result)\r\n    }\r\n    getCellCount(options) {\r\n        var {\r\n            intervalCount: intervalCount,\r\n            viewType: viewType,\r\n            startDayHour: startDayHour,\r\n            endDayHour: endDayHour,\r\n            hoursInterval: hoursInterval\r\n        } = options;\r\n        var cellCountInDay = this.getCellCountInDay(startDayHour, endDayHour, hoursInterval);\r\n        var columnCountInDay = isHorizontalView(viewType) ? cellCountInDay : 1;\r\n        return this.daysInInterval * intervalCount * columnCountInDay\r\n    }\r\n    getRowCount(options) {\r\n        var {\r\n            viewType: viewType,\r\n            startDayHour: startDayHour,\r\n            endDayHour: endDayHour,\r\n            hoursInterval: hoursInterval\r\n        } = options;\r\n        var cellCountInDay = this.getCellCountInDay(startDayHour, endDayHour, hoursInterval);\r\n        var rowCountInDay = !isHorizontalView(viewType) ? cellCountInDay : 1;\r\n        return rowCountInDay\r\n    }\r\n    setHiddenInterval(startDayHour, endDayHour, hoursInterval) {\r\n        this.hiddenInterval = DAY_MS - this.getVisibleDayDuration(startDayHour, endDayHour, hoursInterval)\r\n    }\r\n    getVisibleDayDuration(startDayHour, endDayHour, hoursInterval) {\r\n        var cellCountInDay = this.getCellCountInDay(startDayHour, endDayHour, hoursInterval);\r\n        return hoursInterval * cellCountInDay * HOUR_MS\r\n    }\r\n    getFirstDayOfWeek(firstDayOfWeekOption) {\r\n        return firstDayOfWeekOption\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}