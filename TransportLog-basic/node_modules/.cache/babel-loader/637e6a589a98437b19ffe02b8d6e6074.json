{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scheduler/recurrence.js)\r\n * Version: 22.1.6\r\n * Build date: Tue Oct 18 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport errors from \"../../core/errors\";\nimport { each } from \"../../core/utils/iterator\";\nimport { RRule, RRuleSet } from \"rrule\";\nimport dateUtils from \"../../core/utils/date\";\nimport timeZoneUtils from \"./utils.timeZone\";\nvar toMs = dateUtils.dateToMilliseconds;\nvar ruleNames = [\"freq\", \"interval\", \"byday\", \"byweekno\", \"byyearday\", \"bymonth\", \"bymonthday\", \"count\", \"until\", \"byhour\", \"byminute\", \"bysecond\", \"bysetpos\", \"wkst\"];\nvar freqNames = [\"DAILY\", \"WEEKLY\", \"MONTHLY\", \"YEARLY\", \"SECONDLY\", \"MINUTELY\", \"HOURLY\"];\nvar days = {\n  SU: 0,\n  MO: 1,\n  TU: 2,\n  WE: 3,\n  TH: 4,\n  FR: 5,\n  SA: 6\n};\nvar loggedWarnings = [];\nvar MS_IN_HOUR = 36e5;\nvar MS_IN_DAY = 24 * MS_IN_HOUR;\nvar recurrence = null;\nexport function getRecurrenceProcessor() {\n  if (!recurrence) {\n    recurrence = new RecurrenceProcessor();\n  }\n\n  return recurrence;\n}\n\nclass RecurrenceProcessor {\n  constructor() {\n    this.rRule = null;\n    this.rRuleSet = null;\n    this.validator = new RecurrenceValidator();\n  }\n\n  generateDates(options) {\n    var recurrenceRule = this.evalRecurrenceRule(options.rule);\n    var rule = recurrenceRule.rule;\n\n    if (!recurrenceRule.isValid || !rule.freq) {\n      return [];\n    }\n\n    var rruleIntervalParams = this._createRruleIntervalParams(options);\n\n    this._initializeRRule(options, rruleIntervalParams.startIntervalDate, rule.until);\n\n    return this.rRuleSet.between(rruleIntervalParams.minViewDate, rruleIntervalParams.maxViewDate, true).filter(date => date.getTime() + rruleIntervalParams.appointmentDuration >= rruleIntervalParams.minViewTime).map(date => this._convertRruleResult(rruleIntervalParams, options, date));\n  }\n\n  _createRruleIntervalParams(options) {\n    var {\n      start: start,\n      min: min,\n      max: max,\n      appointmentTimezoneOffset: appointmentTimezoneOffset\n    } = options;\n    var clientOffsets_startDate = timeZoneUtils.getClientTimezoneOffset(start),\n        clientOffsets_minViewDate = timeZoneUtils.getClientTimezoneOffset(min),\n        clientOffsets_maxViewDate = timeZoneUtils.getClientTimezoneOffset(max);\n    var duration = options.end ? options.end.getTime() - options.start.getTime() : 0;\n    var startIntervalDate = timeZoneUtils.setOffsetsToDate(options.start, [-clientOffsets_startDate, appointmentTimezoneOffset]);\n    var minViewTime = options.min.getTime() - clientOffsets_minViewDate + appointmentTimezoneOffset;\n    var minViewDate = new Date(minViewTime - duration);\n    var maxViewDate = timeZoneUtils.setOffsetsToDate(options.max, [-clientOffsets_maxViewDate, appointmentTimezoneOffset]);\n    var startDateDSTDifferenceMs = timeZoneUtils.getDiffBetweenClientTimezoneOffsets(options.start, startIntervalDate);\n    var switchToSummerTime = startDateDSTDifferenceMs < 0;\n    return {\n      startIntervalDate: startIntervalDate,\n      minViewTime: minViewTime,\n      minViewDate: minViewDate,\n      maxViewDate: maxViewDate,\n      startIntervalDateDSTShift: switchToSummerTime ? 0 : startDateDSTDifferenceMs,\n      appointmentDuration: duration\n    };\n  }\n\n  _convertRruleResult(rruleIntervalParams, options, rruleDate) {\n    var localTimezoneOffset = timeZoneUtils.getClientTimezoneOffset(rruleDate);\n    var additionalWorkaroundOffsetForRrule = localTimezoneOffset / MS_IN_HOUR <= -13 ? -MS_IN_DAY : 0;\n    var convertedBackDate = timeZoneUtils.setOffsetsToDate(rruleDate, [localTimezoneOffset, additionalWorkaroundOffsetForRrule, -options.appointmentTimezoneOffset, rruleIntervalParams.startIntervalDateDSTShift]);\n    var convertedDateDSTShift = timeZoneUtils.getDiffBetweenClientTimezoneOffsets(convertedBackDate, rruleDate);\n    var switchToSummerTime = convertedDateDSTShift < 0;\n    var resultDate = timeZoneUtils.setOffsetsToDate(convertedBackDate, [convertedDateDSTShift]);\n    var resultDateDSTShift = timeZoneUtils.getDiffBetweenClientTimezoneOffsets(resultDate, convertedBackDate);\n\n    if (resultDateDSTShift && switchToSummerTime) {\n      return new Date(resultDate.getTime() + resultDateDSTShift);\n    }\n\n    return resultDate;\n  }\n\n  hasRecurrence(options) {\n    return !!this.generateDates(options).length;\n  }\n\n  evalRecurrenceRule(rule) {\n    var result = {\n      rule: {},\n      isValid: false\n    };\n\n    if (rule) {\n      result.rule = this._parseRecurrenceRule(rule);\n      result.isValid = this.validator.validateRRule(result.rule, rule);\n    }\n\n    return result;\n  }\n\n  isValidRecurrenceRule(rule) {\n    return this.evalRecurrenceRule(rule).isValid;\n  }\n\n  daysFromByDayRule(rule) {\n    var result = [];\n\n    if (rule.byday) {\n      if (Array.isArray(rule.byday)) {\n        result = rule.byday;\n      } else {\n        result = rule.byday.split(\",\");\n      }\n    }\n\n    return result.map(item => {\n      var match = item.match(/[A-Za-z]+/);\n      return !!match && match[0];\n    }).filter(item => !!item);\n  }\n\n  getAsciiStringByDate(date) {\n    var currentOffset = date.getTimezoneOffset() * toMs(\"minute\");\n    var offsetDate = new Date(date.getTime() + currentOffset);\n    return offsetDate.getFullYear() + (\"0\" + (offsetDate.getMonth() + 1)).slice(-2) + (\"0\" + offsetDate.getDate()).slice(-2) + \"T\" + (\"0\" + offsetDate.getHours()).slice(-2) + (\"0\" + offsetDate.getMinutes()).slice(-2) + (\"0\" + offsetDate.getSeconds()).slice(-2) + \"Z\";\n  }\n\n  getRecurrenceString(object) {\n    if (!object || !object.freq) {\n      return;\n    }\n\n    var result = \"\";\n\n    for (var field in object) {\n      var value = object[field];\n\n      if (\"interval\" === field && value < 2) {\n        continue;\n      }\n\n      if (\"until\" === field) {\n        value = this.getAsciiStringByDate(value);\n      }\n\n      result += field + \"=\" + value + \";\";\n    }\n\n    result = result.substring(0, result.length - 1);\n    return result.toUpperCase();\n  }\n\n  _parseExceptionToRawArray(value) {\n    return value.match(/(\\d{4})(\\d{2})(\\d{2})(T(\\d{2})(\\d{2})(\\d{2}))?(Z)?/);\n  }\n\n  getDateByAsciiString(exceptionText) {\n    if (\"string\" !== typeof exceptionText) {\n      return exceptionText;\n    }\n\n    var result = this._parseExceptionToRawArray(exceptionText);\n\n    if (!result) {\n      return null;\n    }\n\n    var [year, month, date, hours, minutes, seconds, isUtc] = this._createDateTuple(result);\n\n    if (isUtc) {\n      return new Date(Date.UTC(year, month, date, hours, minutes, seconds));\n    }\n\n    return new Date(year, month, date, hours, minutes, seconds);\n  }\n\n  _dispose() {\n    if (this.rRuleSet) {\n      delete this.rRuleSet;\n      this.rRuleSet = null;\n    }\n\n    if (this.rRule) {\n      delete this.rRule;\n      this.rRule = null;\n    }\n  }\n\n  _getTimeZoneOffset() {\n    return new Date().getTimezoneOffset();\n  }\n\n  _initializeRRule(options, startDateUtc, until) {\n    var ruleOptions = RRule.parseString(options.rule);\n    var firstDayOfWeek = options.firstDayOfWeek;\n    ruleOptions.dtstart = startDateUtc;\n\n    if (!ruleOptions.wkst && firstDayOfWeek) {\n      ruleOptions.wkst = [6, 0, 1, 2, 3, 4, 5][firstDayOfWeek];\n    }\n\n    if (until) {\n      ruleOptions.until = timeZoneUtils.setOffsetsToDate(until, [-timeZoneUtils.getClientTimezoneOffset(until), options.appointmentTimezoneOffset]);\n    }\n\n    this._createRRule(ruleOptions);\n\n    if (options.exception) {\n      var exceptionStrings = options.exception;\n      var exceptionDates = exceptionStrings.split(\",\").map(rule => this.getDateByAsciiString(rule));\n      exceptionDates.forEach(date => {\n        if (options.getPostProcessedException) {\n          date = options.getPostProcessedException(date);\n        }\n\n        var utcDate = timeZoneUtils.setOffsetsToDate(date, [-timeZoneUtils.getClientTimezoneOffset(date), options.appointmentTimezoneOffset]);\n        this.rRuleSet.exdate(utcDate);\n      });\n    }\n  }\n\n  _createRRule(ruleOptions) {\n    this._dispose();\n\n    this.rRuleSet = new RRuleSet();\n    this.rRule = new RRule(ruleOptions);\n    this.rRuleSet.rrule(this.rRule);\n  }\n\n  _parseRecurrenceRule(recurrence) {\n    var ruleObject = {};\n    var ruleParts = recurrence.split(\";\");\n\n    for (var i = 0, len = ruleParts.length; i < len; i++) {\n      var rule = ruleParts[i].split(\"=\");\n      var ruleName = rule[0].toLowerCase();\n      var ruleValue = rule[1];\n      ruleObject[ruleName] = ruleValue;\n    }\n\n    var count = parseInt(ruleObject.count);\n\n    if (!isNaN(count)) {\n      ruleObject.count = count;\n    }\n\n    if (ruleObject.interval) {\n      var interval = parseInt(ruleObject.interval);\n\n      if (!isNaN(interval)) {\n        ruleObject.interval = interval;\n      }\n    } else {\n      ruleObject.interval = 1;\n    }\n\n    if (ruleObject.freq && ruleObject.until) {\n      ruleObject.until = this.getDateByAsciiString(ruleObject.until);\n    }\n\n    return ruleObject;\n  }\n\n  _createDateTuple(parseResult) {\n    var isUtc = void 0 !== parseResult[8];\n    parseResult.shift();\n\n    if (void 0 === parseResult[3]) {\n      parseResult.splice(3);\n    } else {\n      parseResult.splice(3, 1);\n      parseResult.splice(6);\n    }\n\n    parseResult[1]--;\n    parseResult.unshift(null);\n    return [parseInt(parseResult[1]), parseInt(parseResult[2]), parseInt(parseResult[3]), parseInt(parseResult[4]) || 0, parseInt(parseResult[5]) || 0, parseInt(parseResult[6]) || 0, isUtc];\n  }\n\n}\n\nclass RecurrenceValidator {\n  validateRRule(rule, recurrence) {\n    if (this._brokenRuleNameExists(rule) || !freqNames.includes(rule.freq) || this._wrongCountRule(rule) || this._wrongIntervalRule(rule) || this._wrongDayOfWeek(rule) || this._wrongByMonthDayRule(rule) || this._wrongByMonth(rule) || this._wrongUntilRule(rule)) {\n      this._logBrokenRule(recurrence);\n\n      return false;\n    }\n\n    return true;\n  }\n\n  _wrongUntilRule(rule) {\n    var wrongUntil = false;\n    var until = rule.until;\n\n    if (void 0 !== until && !(until instanceof Date)) {\n      wrongUntil = true;\n    }\n\n    return wrongUntil;\n  }\n\n  _wrongCountRule(rule) {\n    var wrongCount = false;\n    var count = rule.count;\n\n    if (count && \"string\" === typeof count) {\n      wrongCount = true;\n    }\n\n    return wrongCount;\n  }\n\n  _wrongByMonthDayRule(rule) {\n    var wrongByMonthDay = false;\n    var byMonthDay = rule.bymonthday;\n\n    if (byMonthDay && isNaN(parseInt(byMonthDay))) {\n      wrongByMonthDay = true;\n    }\n\n    return wrongByMonthDay;\n  }\n\n  _wrongByMonth(rule) {\n    var wrongByMonth = false;\n    var byMonth = rule.bymonth;\n\n    if (byMonth && isNaN(parseInt(byMonth))) {\n      wrongByMonth = true;\n    }\n\n    return wrongByMonth;\n  }\n\n  _wrongIntervalRule(rule) {\n    var wrongInterval = false;\n    var interval = rule.interval;\n\n    if (interval && \"string\" === typeof interval) {\n      wrongInterval = true;\n    }\n\n    return wrongInterval;\n  }\n\n  _wrongDayOfWeek(rule) {\n    var byDay = rule.byday;\n    var daysByRule = getRecurrenceProcessor().daysFromByDayRule(rule);\n    var brokenDaysExist = false;\n\n    if (\"\" === byDay) {\n      brokenDaysExist = true;\n    }\n\n    each(daysByRule, function (_, day) {\n      if (!Object.prototype.hasOwnProperty.call(days, day)) {\n        brokenDaysExist = true;\n        return false;\n      }\n    });\n    return brokenDaysExist;\n  }\n\n  _brokenRuleNameExists(rule) {\n    var brokenRuleExists = false;\n    each(rule, function (ruleName) {\n      if (!ruleNames.includes(ruleName)) {\n        brokenRuleExists = true;\n        return false;\n      }\n    });\n    return brokenRuleExists;\n  }\n\n  _logBrokenRule(recurrence) {\n    if (!loggedWarnings.includes(recurrence)) {\n      errors.log(\"W0006\", recurrence);\n      loggedWarnings.push(recurrence);\n    }\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Zoran/source/repos/TransportApp/TransportLog-basic/node_modules/devextreme/esm/ui/scheduler/recurrence.js"],"names":["errors","each","RRule","RRuleSet","dateUtils","timeZoneUtils","toMs","dateToMilliseconds","ruleNames","freqNames","days","SU","MO","TU","WE","TH","FR","SA","loggedWarnings","MS_IN_HOUR","MS_IN_DAY","recurrence","getRecurrenceProcessor","RecurrenceProcessor","constructor","rRule","rRuleSet","validator","RecurrenceValidator","generateDates","options","recurrenceRule","evalRecurrenceRule","rule","isValid","freq","rruleIntervalParams","_createRruleIntervalParams","_initializeRRule","startIntervalDate","until","between","minViewDate","maxViewDate","filter","date","getTime","appointmentDuration","minViewTime","map","_convertRruleResult","start","min","max","appointmentTimezoneOffset","clientOffsets_startDate","getClientTimezoneOffset","clientOffsets_minViewDate","clientOffsets_maxViewDate","duration","end","setOffsetsToDate","Date","startDateDSTDifferenceMs","getDiffBetweenClientTimezoneOffsets","switchToSummerTime","startIntervalDateDSTShift","rruleDate","localTimezoneOffset","additionalWorkaroundOffsetForRrule","convertedBackDate","convertedDateDSTShift","resultDate","resultDateDSTShift","hasRecurrence","length","result","_parseRecurrenceRule","validateRRule","isValidRecurrenceRule","daysFromByDayRule","byday","Array","isArray","split","item","match","getAsciiStringByDate","currentOffset","getTimezoneOffset","offsetDate","getFullYear","getMonth","slice","getDate","getHours","getMinutes","getSeconds","getRecurrenceString","object","field","value","substring","toUpperCase","_parseExceptionToRawArray","getDateByAsciiString","exceptionText","year","month","hours","minutes","seconds","isUtc","_createDateTuple","UTC","_dispose","_getTimeZoneOffset","startDateUtc","ruleOptions","parseString","firstDayOfWeek","dtstart","wkst","_createRRule","exception","exceptionStrings","exceptionDates","forEach","getPostProcessedException","utcDate","exdate","rrule","ruleObject","ruleParts","i","len","ruleName","toLowerCase","ruleValue","count","parseInt","isNaN","interval","parseResult","shift","splice","unshift","_brokenRuleNameExists","includes","_wrongCountRule","_wrongIntervalRule","_wrongDayOfWeek","_wrongByMonthDayRule","_wrongByMonth","_wrongUntilRule","_logBrokenRule","wrongUntil","wrongCount","wrongByMonthDay","byMonthDay","bymonthday","wrongByMonth","byMonth","bymonth","wrongInterval","byDay","daysByRule","brokenDaysExist","_","day","Object","prototype","hasOwnProperty","call","brokenRuleExists","log","push"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (esm/ui/scheduler/recurrence.js)\r\n * Version: 22.1.6\r\n * Build date: Tue Oct 18 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport errors from \"../../core/errors\";\r\nimport {\r\n    each\r\n} from \"../../core/utils/iterator\";\r\nimport {\r\n    RRule,\r\n    RRuleSet\r\n} from \"rrule\";\r\nimport dateUtils from \"../../core/utils/date\";\r\nimport timeZoneUtils from \"./utils.timeZone\";\r\nvar toMs = dateUtils.dateToMilliseconds;\r\nvar ruleNames = [\"freq\", \"interval\", \"byday\", \"byweekno\", \"byyearday\", \"bymonth\", \"bymonthday\", \"count\", \"until\", \"byhour\", \"byminute\", \"bysecond\", \"bysetpos\", \"wkst\"];\r\nvar freqNames = [\"DAILY\", \"WEEKLY\", \"MONTHLY\", \"YEARLY\", \"SECONDLY\", \"MINUTELY\", \"HOURLY\"];\r\nvar days = {\r\n    SU: 0,\r\n    MO: 1,\r\n    TU: 2,\r\n    WE: 3,\r\n    TH: 4,\r\n    FR: 5,\r\n    SA: 6\r\n};\r\nvar loggedWarnings = [];\r\nvar MS_IN_HOUR = 36e5;\r\nvar MS_IN_DAY = 24 * MS_IN_HOUR;\r\nvar recurrence = null;\r\nexport function getRecurrenceProcessor() {\r\n    if (!recurrence) {\r\n        recurrence = new RecurrenceProcessor\r\n    }\r\n    return recurrence\r\n}\r\nclass RecurrenceProcessor {\r\n    constructor() {\r\n        this.rRule = null;\r\n        this.rRuleSet = null;\r\n        this.validator = new RecurrenceValidator\r\n    }\r\n    generateDates(options) {\r\n        var recurrenceRule = this.evalRecurrenceRule(options.rule);\r\n        var rule = recurrenceRule.rule;\r\n        if (!recurrenceRule.isValid || !rule.freq) {\r\n            return []\r\n        }\r\n        var rruleIntervalParams = this._createRruleIntervalParams(options);\r\n        this._initializeRRule(options, rruleIntervalParams.startIntervalDate, rule.until);\r\n        return this.rRuleSet.between(rruleIntervalParams.minViewDate, rruleIntervalParams.maxViewDate, true).filter(date => date.getTime() + rruleIntervalParams.appointmentDuration >= rruleIntervalParams.minViewTime).map(date => this._convertRruleResult(rruleIntervalParams, options, date))\r\n    }\r\n    _createRruleIntervalParams(options) {\r\n        var {\r\n            start: start,\r\n            min: min,\r\n            max: max,\r\n            appointmentTimezoneOffset: appointmentTimezoneOffset\r\n        } = options;\r\n        var clientOffsets_startDate = timeZoneUtils.getClientTimezoneOffset(start),\r\n            clientOffsets_minViewDate = timeZoneUtils.getClientTimezoneOffset(min),\r\n            clientOffsets_maxViewDate = timeZoneUtils.getClientTimezoneOffset(max);\r\n        var duration = options.end ? options.end.getTime() - options.start.getTime() : 0;\r\n        var startIntervalDate = timeZoneUtils.setOffsetsToDate(options.start, [-clientOffsets_startDate, appointmentTimezoneOffset]);\r\n        var minViewTime = options.min.getTime() - clientOffsets_minViewDate + appointmentTimezoneOffset;\r\n        var minViewDate = new Date(minViewTime - duration);\r\n        var maxViewDate = timeZoneUtils.setOffsetsToDate(options.max, [-clientOffsets_maxViewDate, appointmentTimezoneOffset]);\r\n        var startDateDSTDifferenceMs = timeZoneUtils.getDiffBetweenClientTimezoneOffsets(options.start, startIntervalDate);\r\n        var switchToSummerTime = startDateDSTDifferenceMs < 0;\r\n        return {\r\n            startIntervalDate: startIntervalDate,\r\n            minViewTime: minViewTime,\r\n            minViewDate: minViewDate,\r\n            maxViewDate: maxViewDate,\r\n            startIntervalDateDSTShift: switchToSummerTime ? 0 : startDateDSTDifferenceMs,\r\n            appointmentDuration: duration\r\n        }\r\n    }\r\n    _convertRruleResult(rruleIntervalParams, options, rruleDate) {\r\n        var localTimezoneOffset = timeZoneUtils.getClientTimezoneOffset(rruleDate);\r\n        var additionalWorkaroundOffsetForRrule = localTimezoneOffset / MS_IN_HOUR <= -13 ? -MS_IN_DAY : 0;\r\n        var convertedBackDate = timeZoneUtils.setOffsetsToDate(rruleDate, [localTimezoneOffset, additionalWorkaroundOffsetForRrule, -options.appointmentTimezoneOffset, rruleIntervalParams.startIntervalDateDSTShift]);\r\n        var convertedDateDSTShift = timeZoneUtils.getDiffBetweenClientTimezoneOffsets(convertedBackDate, rruleDate);\r\n        var switchToSummerTime = convertedDateDSTShift < 0;\r\n        var resultDate = timeZoneUtils.setOffsetsToDate(convertedBackDate, [convertedDateDSTShift]);\r\n        var resultDateDSTShift = timeZoneUtils.getDiffBetweenClientTimezoneOffsets(resultDate, convertedBackDate);\r\n        if (resultDateDSTShift && switchToSummerTime) {\r\n            return new Date(resultDate.getTime() + resultDateDSTShift)\r\n        }\r\n        return resultDate\r\n    }\r\n    hasRecurrence(options) {\r\n        return !!this.generateDates(options).length\r\n    }\r\n    evalRecurrenceRule(rule) {\r\n        var result = {\r\n            rule: {},\r\n            isValid: false\r\n        };\r\n        if (rule) {\r\n            result.rule = this._parseRecurrenceRule(rule);\r\n            result.isValid = this.validator.validateRRule(result.rule, rule)\r\n        }\r\n        return result\r\n    }\r\n    isValidRecurrenceRule(rule) {\r\n        return this.evalRecurrenceRule(rule).isValid\r\n    }\r\n    daysFromByDayRule(rule) {\r\n        var result = [];\r\n        if (rule.byday) {\r\n            if (Array.isArray(rule.byday)) {\r\n                result = rule.byday\r\n            } else {\r\n                result = rule.byday.split(\",\")\r\n            }\r\n        }\r\n        return result.map(item => {\r\n            var match = item.match(/[A-Za-z]+/);\r\n            return !!match && match[0]\r\n        }).filter(item => !!item)\r\n    }\r\n    getAsciiStringByDate(date) {\r\n        var currentOffset = date.getTimezoneOffset() * toMs(\"minute\");\r\n        var offsetDate = new Date(date.getTime() + currentOffset);\r\n        return offsetDate.getFullYear() + (\"0\" + (offsetDate.getMonth() + 1)).slice(-2) + (\"0\" + offsetDate.getDate()).slice(-2) + \"T\" + (\"0\" + offsetDate.getHours()).slice(-2) + (\"0\" + offsetDate.getMinutes()).slice(-2) + (\"0\" + offsetDate.getSeconds()).slice(-2) + \"Z\"\r\n    }\r\n    getRecurrenceString(object) {\r\n        if (!object || !object.freq) {\r\n            return\r\n        }\r\n        var result = \"\";\r\n        for (var field in object) {\r\n            var value = object[field];\r\n            if (\"interval\" === field && value < 2) {\r\n                continue\r\n            }\r\n            if (\"until\" === field) {\r\n                value = this.getAsciiStringByDate(value)\r\n            }\r\n            result += field + \"=\" + value + \";\"\r\n        }\r\n        result = result.substring(0, result.length - 1);\r\n        return result.toUpperCase()\r\n    }\r\n    _parseExceptionToRawArray(value) {\r\n        return value.match(/(\\d{4})(\\d{2})(\\d{2})(T(\\d{2})(\\d{2})(\\d{2}))?(Z)?/)\r\n    }\r\n    getDateByAsciiString(exceptionText) {\r\n        if (\"string\" !== typeof exceptionText) {\r\n            return exceptionText\r\n        }\r\n        var result = this._parseExceptionToRawArray(exceptionText);\r\n        if (!result) {\r\n            return null\r\n        }\r\n        var [year, month, date, hours, minutes, seconds, isUtc] = this._createDateTuple(result);\r\n        if (isUtc) {\r\n            return new Date(Date.UTC(year, month, date, hours, minutes, seconds))\r\n        }\r\n        return new Date(year, month, date, hours, minutes, seconds)\r\n    }\r\n    _dispose() {\r\n        if (this.rRuleSet) {\r\n            delete this.rRuleSet;\r\n            this.rRuleSet = null\r\n        }\r\n        if (this.rRule) {\r\n            delete this.rRule;\r\n            this.rRule = null\r\n        }\r\n    }\r\n    _getTimeZoneOffset() {\r\n        return (new Date).getTimezoneOffset()\r\n    }\r\n    _initializeRRule(options, startDateUtc, until) {\r\n        var ruleOptions = RRule.parseString(options.rule);\r\n        var firstDayOfWeek = options.firstDayOfWeek;\r\n        ruleOptions.dtstart = startDateUtc;\r\n        if (!ruleOptions.wkst && firstDayOfWeek) {\r\n            ruleOptions.wkst = [6, 0, 1, 2, 3, 4, 5][firstDayOfWeek]\r\n        }\r\n        if (until) {\r\n            ruleOptions.until = timeZoneUtils.setOffsetsToDate(until, [-timeZoneUtils.getClientTimezoneOffset(until), options.appointmentTimezoneOffset])\r\n        }\r\n        this._createRRule(ruleOptions);\r\n        if (options.exception) {\r\n            var exceptionStrings = options.exception;\r\n            var exceptionDates = exceptionStrings.split(\",\").map(rule => this.getDateByAsciiString(rule));\r\n            exceptionDates.forEach(date => {\r\n                if (options.getPostProcessedException) {\r\n                    date = options.getPostProcessedException(date)\r\n                }\r\n                var utcDate = timeZoneUtils.setOffsetsToDate(date, [-timeZoneUtils.getClientTimezoneOffset(date), options.appointmentTimezoneOffset]);\r\n                this.rRuleSet.exdate(utcDate)\r\n            })\r\n        }\r\n    }\r\n    _createRRule(ruleOptions) {\r\n        this._dispose();\r\n        this.rRuleSet = new RRuleSet;\r\n        this.rRule = new RRule(ruleOptions);\r\n        this.rRuleSet.rrule(this.rRule)\r\n    }\r\n    _parseRecurrenceRule(recurrence) {\r\n        var ruleObject = {};\r\n        var ruleParts = recurrence.split(\";\");\r\n        for (var i = 0, len = ruleParts.length; i < len; i++) {\r\n            var rule = ruleParts[i].split(\"=\");\r\n            var ruleName = rule[0].toLowerCase();\r\n            var ruleValue = rule[1];\r\n            ruleObject[ruleName] = ruleValue\r\n        }\r\n        var count = parseInt(ruleObject.count);\r\n        if (!isNaN(count)) {\r\n            ruleObject.count = count\r\n        }\r\n        if (ruleObject.interval) {\r\n            var interval = parseInt(ruleObject.interval);\r\n            if (!isNaN(interval)) {\r\n                ruleObject.interval = interval\r\n            }\r\n        } else {\r\n            ruleObject.interval = 1\r\n        }\r\n        if (ruleObject.freq && ruleObject.until) {\r\n            ruleObject.until = this.getDateByAsciiString(ruleObject.until)\r\n        }\r\n        return ruleObject\r\n    }\r\n    _createDateTuple(parseResult) {\r\n        var isUtc = void 0 !== parseResult[8];\r\n        parseResult.shift();\r\n        if (void 0 === parseResult[3]) {\r\n            parseResult.splice(3)\r\n        } else {\r\n            parseResult.splice(3, 1);\r\n            parseResult.splice(6)\r\n        }\r\n        parseResult[1]--;\r\n        parseResult.unshift(null);\r\n        return [parseInt(parseResult[1]), parseInt(parseResult[2]), parseInt(parseResult[3]), parseInt(parseResult[4]) || 0, parseInt(parseResult[5]) || 0, parseInt(parseResult[6]) || 0, isUtc]\r\n    }\r\n}\r\nclass RecurrenceValidator {\r\n    validateRRule(rule, recurrence) {\r\n        if (this._brokenRuleNameExists(rule) || !freqNames.includes(rule.freq) || this._wrongCountRule(rule) || this._wrongIntervalRule(rule) || this._wrongDayOfWeek(rule) || this._wrongByMonthDayRule(rule) || this._wrongByMonth(rule) || this._wrongUntilRule(rule)) {\r\n            this._logBrokenRule(recurrence);\r\n            return false\r\n        }\r\n        return true\r\n    }\r\n    _wrongUntilRule(rule) {\r\n        var wrongUntil = false;\r\n        var until = rule.until;\r\n        if (void 0 !== until && !(until instanceof Date)) {\r\n            wrongUntil = true\r\n        }\r\n        return wrongUntil\r\n    }\r\n    _wrongCountRule(rule) {\r\n        var wrongCount = false;\r\n        var count = rule.count;\r\n        if (count && \"string\" === typeof count) {\r\n            wrongCount = true\r\n        }\r\n        return wrongCount\r\n    }\r\n    _wrongByMonthDayRule(rule) {\r\n        var wrongByMonthDay = false;\r\n        var byMonthDay = rule.bymonthday;\r\n        if (byMonthDay && isNaN(parseInt(byMonthDay))) {\r\n            wrongByMonthDay = true\r\n        }\r\n        return wrongByMonthDay\r\n    }\r\n    _wrongByMonth(rule) {\r\n        var wrongByMonth = false;\r\n        var byMonth = rule.bymonth;\r\n        if (byMonth && isNaN(parseInt(byMonth))) {\r\n            wrongByMonth = true\r\n        }\r\n        return wrongByMonth\r\n    }\r\n    _wrongIntervalRule(rule) {\r\n        var wrongInterval = false;\r\n        var interval = rule.interval;\r\n        if (interval && \"string\" === typeof interval) {\r\n            wrongInterval = true\r\n        }\r\n        return wrongInterval\r\n    }\r\n    _wrongDayOfWeek(rule) {\r\n        var byDay = rule.byday;\r\n        var daysByRule = getRecurrenceProcessor().daysFromByDayRule(rule);\r\n        var brokenDaysExist = false;\r\n        if (\"\" === byDay) {\r\n            brokenDaysExist = true\r\n        }\r\n        each(daysByRule, (function(_, day) {\r\n            if (!Object.prototype.hasOwnProperty.call(days, day)) {\r\n                brokenDaysExist = true;\r\n                return false\r\n            }\r\n        }));\r\n        return brokenDaysExist\r\n    }\r\n    _brokenRuleNameExists(rule) {\r\n        var brokenRuleExists = false;\r\n        each(rule, (function(ruleName) {\r\n            if (!ruleNames.includes(ruleName)) {\r\n                brokenRuleExists = true;\r\n                return false\r\n            }\r\n        }));\r\n        return brokenRuleExists\r\n    }\r\n    _logBrokenRule(recurrence) {\r\n        if (!loggedWarnings.includes(recurrence)) {\r\n            errors.log(\"W0006\", recurrence);\r\n            loggedWarnings.push(recurrence)\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}