{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scheduler/appointments/dataProvider/utils.js)\r\n * Version: 22.1.6\r\n * Build date: Tue Oct 18 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport dateUtils from \"../../../../core/utils/date\";\nimport timeZoneUtils from \"../../utils.timeZone\";\nimport dateSerialization from \"../../../../core/utils/date_serialization\";\nimport { ExpressionUtils } from \"../../expressionUtils\";\nvar toMs = dateUtils.dateToMilliseconds;\nvar FULL_DATE_FORMAT = \"yyyyMMddTHHmmss\";\nexport var compareDateWithStartDayHour = (startDate, endDate, startDayHour, allDay, severalDays) => {\n  var startTime = dateUtils.dateTimeFromDecimal(startDayHour);\n  var result = startDate.getHours() >= startTime.hours && startDate.getMinutes() >= startTime.minutes || endDate.getHours() === startTime.hours && endDate.getMinutes() > startTime.minutes || endDate.getHours() > startTime.hours || severalDays || allDay;\n  return result;\n};\nexport var compareDateWithEndDayHour = options => {\n  var {\n    startDate: startDate,\n    endDate: endDate,\n    startDayHour: startDayHour,\n    endDayHour: endDayHour,\n    viewStartDayHour: viewStartDayHour,\n    viewEndDayHour: viewEndDayHour,\n    allDay: allDay,\n    severalDays: severalDays,\n    min: min,\n    max: max,\n    checkIntersectViewport: checkIntersectViewport\n  } = options;\n  var hiddenInterval = (24 - viewEndDayHour + viewStartDayHour) * toMs(\"hour\");\n  var apptDuration = endDate.getTime() - startDate.getTime();\n  var delta = (hiddenInterval - apptDuration) / toMs(\"hour\");\n  var apptStartHour = startDate.getHours();\n  var apptStartMinutes = startDate.getMinutes();\n  var result;\n  var endTime = dateUtils.dateTimeFromDecimal(endDayHour);\n  var startTime = dateUtils.dateTimeFromDecimal(startDayHour);\n  var apptIntersectViewport = startDate < max && endDate > min;\n  result = checkIntersectViewport && apptIntersectViewport || apptStartHour < endTime.hours || apptStartHour === endTime.hours && apptStartMinutes < endTime.minutes || allDay && startDate <= max || severalDays && apptIntersectViewport && (apptStartHour < endTime.hours || 60 * endDate.getHours() + endDate.getMinutes() > 60 * startTime.hours);\n\n  if (apptDuration < hiddenInterval) {\n    if (apptStartHour > endTime.hours && apptStartMinutes > endTime.minutes && delta <= apptStartHour - endDayHour) {\n      result = false;\n    }\n  }\n\n  return result;\n};\nexport var getAppointmentTakesSeveralDays = adapter => !dateUtils.sameDate(adapter.startDate, adapter.endDate);\nexport var _isEndDateWrong = (startDate, endDate) => !endDate || isNaN(endDate.getTime()) || startDate.getTime() > endDate.getTime();\nexport var _appointmentPartInInterval = (startDate, endDate, startDayHour, endDayHour) => {\n  var apptStartDayHour = startDate.getHours();\n  var apptEndDayHour = endDate.getHours();\n  return apptStartDayHour <= startDayHour && apptEndDayHour <= endDayHour && apptEndDayHour >= startDayHour || apptEndDayHour >= endDayHour && apptStartDayHour <= endDayHour && apptStartDayHour >= startDayHour;\n};\nexport var getRecurrenceException = (appointmentAdapter, timeZoneCalculator, timeZone) => {\n  var recurrenceException = appointmentAdapter.recurrenceException;\n\n  if (recurrenceException) {\n    var exceptions = recurrenceException.split(\",\");\n\n    for (var i = 0; i < exceptions.length; i++) {\n      exceptions[i] = _convertRecurrenceException(exceptions[i], appointmentAdapter.startDate, timeZoneCalculator, timeZone);\n    }\n\n    return exceptions.join();\n  }\n\n  return recurrenceException;\n};\nexport var _convertRecurrenceException = (exceptionString, startDate, timeZoneCalculator, timeZone) => {\n  exceptionString = exceptionString.replace(/\\s/g, \"\");\n\n  var getConvertedToTimeZone = date => timeZoneCalculator.createDate(date, {\n    path: \"toGrid\"\n  });\n\n  var exceptionDate = dateSerialization.deserializeDate(exceptionString);\n  var convertedStartDate = getConvertedToTimeZone(startDate);\n  var convertedExceptionDate = getConvertedToTimeZone(exceptionDate);\n  convertedExceptionDate = timeZoneUtils.correctRecurrenceExceptionByTimezone(convertedExceptionDate, convertedStartDate, timeZone);\n  exceptionString = dateSerialization.serializeDate(convertedExceptionDate, FULL_DATE_FORMAT);\n  return exceptionString;\n};\nexport var replaceWrongEndDate = (appointment, startDate, endDate, appointmentDuration, dataAccessors) => {\n  if (_isEndDateWrong(startDate, endDate)) {\n    var calculatedEndDate = ((isAllDay, startDate) => {\n      if (isAllDay) {\n        return dateUtils.setToDayEnd(new Date(startDate));\n      }\n\n      return new Date(startDate.getTime() + appointmentDuration * toMs(\"minute\"));\n    })(appointment.allDay, startDate);\n\n    dataAccessors.setter.endDate(appointment, calculatedEndDate);\n  }\n};\nexport var sortAppointmentsByStartDate = (appointments, dataAccessors) => {\n  appointments.sort((a, b) => {\n    var firstDate = new Date(ExpressionUtils.getField(dataAccessors, \"startDate\", a.settings || a));\n    var secondDate = new Date(ExpressionUtils.getField(dataAccessors, \"startDate\", b.settings || b));\n    return Math.sign(firstDate.getTime() - secondDate.getTime());\n  });\n};","map":{"version":3,"sources":["C:/Users/Zoran/source/repos/TransportApp/TransportLog-basic/node_modules/devextreme/esm/ui/scheduler/appointments/dataProvider/utils.js"],"names":["dateUtils","timeZoneUtils","dateSerialization","ExpressionUtils","toMs","dateToMilliseconds","FULL_DATE_FORMAT","compareDateWithStartDayHour","startDate","endDate","startDayHour","allDay","severalDays","startTime","dateTimeFromDecimal","result","getHours","hours","getMinutes","minutes","compareDateWithEndDayHour","options","endDayHour","viewStartDayHour","viewEndDayHour","min","max","checkIntersectViewport","hiddenInterval","apptDuration","getTime","delta","apptStartHour","apptStartMinutes","endTime","apptIntersectViewport","getAppointmentTakesSeveralDays","adapter","sameDate","_isEndDateWrong","isNaN","_appointmentPartInInterval","apptStartDayHour","apptEndDayHour","getRecurrenceException","appointmentAdapter","timeZoneCalculator","timeZone","recurrenceException","exceptions","split","i","length","_convertRecurrenceException","join","exceptionString","replace","getConvertedToTimeZone","date","createDate","path","exceptionDate","deserializeDate","convertedStartDate","convertedExceptionDate","correctRecurrenceExceptionByTimezone","serializeDate","replaceWrongEndDate","appointment","appointmentDuration","dataAccessors","calculatedEndDate","isAllDay","setToDayEnd","Date","setter","sortAppointmentsByStartDate","appointments","sort","a","b","firstDate","getField","settings","secondDate","Math","sign"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (esm/ui/scheduler/appointments/dataProvider/utils.js)\r\n * Version: 22.1.6\r\n * Build date: Tue Oct 18 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport dateUtils from \"../../../../core/utils/date\";\r\nimport timeZoneUtils from \"../../utils.timeZone\";\r\nimport dateSerialization from \"../../../../core/utils/date_serialization\";\r\nimport {\r\n    ExpressionUtils\r\n} from \"../../expressionUtils\";\r\nvar toMs = dateUtils.dateToMilliseconds;\r\nvar FULL_DATE_FORMAT = \"yyyyMMddTHHmmss\";\r\nexport var compareDateWithStartDayHour = (startDate, endDate, startDayHour, allDay, severalDays) => {\r\n    var startTime = dateUtils.dateTimeFromDecimal(startDayHour);\r\n    var result = startDate.getHours() >= startTime.hours && startDate.getMinutes() >= startTime.minutes || endDate.getHours() === startTime.hours && endDate.getMinutes() > startTime.minutes || endDate.getHours() > startTime.hours || severalDays || allDay;\r\n    return result\r\n};\r\nexport var compareDateWithEndDayHour = options => {\r\n    var {\r\n        startDate: startDate,\r\n        endDate: endDate,\r\n        startDayHour: startDayHour,\r\n        endDayHour: endDayHour,\r\n        viewStartDayHour: viewStartDayHour,\r\n        viewEndDayHour: viewEndDayHour,\r\n        allDay: allDay,\r\n        severalDays: severalDays,\r\n        min: min,\r\n        max: max,\r\n        checkIntersectViewport: checkIntersectViewport\r\n    } = options;\r\n    var hiddenInterval = (24 - viewEndDayHour + viewStartDayHour) * toMs(\"hour\");\r\n    var apptDuration = endDate.getTime() - startDate.getTime();\r\n    var delta = (hiddenInterval - apptDuration) / toMs(\"hour\");\r\n    var apptStartHour = startDate.getHours();\r\n    var apptStartMinutes = startDate.getMinutes();\r\n    var result;\r\n    var endTime = dateUtils.dateTimeFromDecimal(endDayHour);\r\n    var startTime = dateUtils.dateTimeFromDecimal(startDayHour);\r\n    var apptIntersectViewport = startDate < max && endDate > min;\r\n    result = checkIntersectViewport && apptIntersectViewport || apptStartHour < endTime.hours || apptStartHour === endTime.hours && apptStartMinutes < endTime.minutes || allDay && startDate <= max || severalDays && apptIntersectViewport && (apptStartHour < endTime.hours || 60 * endDate.getHours() + endDate.getMinutes() > 60 * startTime.hours);\r\n    if (apptDuration < hiddenInterval) {\r\n        if (apptStartHour > endTime.hours && apptStartMinutes > endTime.minutes && delta <= apptStartHour - endDayHour) {\r\n            result = false\r\n        }\r\n    }\r\n    return result\r\n};\r\nexport var getAppointmentTakesSeveralDays = adapter => !dateUtils.sameDate(adapter.startDate, adapter.endDate);\r\nexport var _isEndDateWrong = (startDate, endDate) => !endDate || isNaN(endDate.getTime()) || startDate.getTime() > endDate.getTime();\r\nexport var _appointmentPartInInterval = (startDate, endDate, startDayHour, endDayHour) => {\r\n    var apptStartDayHour = startDate.getHours();\r\n    var apptEndDayHour = endDate.getHours();\r\n    return apptStartDayHour <= startDayHour && apptEndDayHour <= endDayHour && apptEndDayHour >= startDayHour || apptEndDayHour >= endDayHour && apptStartDayHour <= endDayHour && apptStartDayHour >= startDayHour\r\n};\r\nexport var getRecurrenceException = (appointmentAdapter, timeZoneCalculator, timeZone) => {\r\n    var recurrenceException = appointmentAdapter.recurrenceException;\r\n    if (recurrenceException) {\r\n        var exceptions = recurrenceException.split(\",\");\r\n        for (var i = 0; i < exceptions.length; i++) {\r\n            exceptions[i] = _convertRecurrenceException(exceptions[i], appointmentAdapter.startDate, timeZoneCalculator, timeZone)\r\n        }\r\n        return exceptions.join()\r\n    }\r\n    return recurrenceException\r\n};\r\nexport var _convertRecurrenceException = (exceptionString, startDate, timeZoneCalculator, timeZone) => {\r\n    exceptionString = exceptionString.replace(/\\s/g, \"\");\r\n    var getConvertedToTimeZone = date => timeZoneCalculator.createDate(date, {\r\n        path: \"toGrid\"\r\n    });\r\n    var exceptionDate = dateSerialization.deserializeDate(exceptionString);\r\n    var convertedStartDate = getConvertedToTimeZone(startDate);\r\n    var convertedExceptionDate = getConvertedToTimeZone(exceptionDate);\r\n    convertedExceptionDate = timeZoneUtils.correctRecurrenceExceptionByTimezone(convertedExceptionDate, convertedStartDate, timeZone);\r\n    exceptionString = dateSerialization.serializeDate(convertedExceptionDate, FULL_DATE_FORMAT);\r\n    return exceptionString\r\n};\r\nexport var replaceWrongEndDate = (appointment, startDate, endDate, appointmentDuration, dataAccessors) => {\r\n    if (_isEndDateWrong(startDate, endDate)) {\r\n        var calculatedEndDate = ((isAllDay, startDate) => {\r\n            if (isAllDay) {\r\n                return dateUtils.setToDayEnd(new Date(startDate))\r\n            }\r\n            return new Date(startDate.getTime() + appointmentDuration * toMs(\"minute\"))\r\n        })(appointment.allDay, startDate);\r\n        dataAccessors.setter.endDate(appointment, calculatedEndDate)\r\n    }\r\n};\r\nexport var sortAppointmentsByStartDate = (appointments, dataAccessors) => {\r\n    appointments.sort((a, b) => {\r\n        var firstDate = new Date(ExpressionUtils.getField(dataAccessors, \"startDate\", a.settings || a));\r\n        var secondDate = new Date(ExpressionUtils.getField(dataAccessors, \"startDate\", b.settings || b));\r\n        return Math.sign(firstDate.getTime() - secondDate.getTime())\r\n    })\r\n};\r\n"]},"metadata":{},"sourceType":"module"}