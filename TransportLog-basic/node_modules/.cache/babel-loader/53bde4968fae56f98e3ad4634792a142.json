{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/ui.scheduler.work_space.grouped.strategy.horizontal.js)\r\n * Version: 22.1.6\r\n * Build date: Tue Oct 18 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { getBoundingRect } from \"../../../core/utils/position\";\nimport { FIRST_GROUP_CELL_CLASS, LAST_GROUP_CELL_CLASS } from \"../classes\";\n\nclass HorizontalGroupedStrategy {\n  constructor(workSpace) {\n    this._workSpace = workSpace;\n  }\n\n  prepareCellIndexes(cellCoordinates, groupIndex, inAllDay) {\n    var groupByDay = this._workSpace.isGroupedByDate();\n\n    if (!groupByDay) {\n      return {\n        rowIndex: cellCoordinates.rowIndex,\n        columnIndex: cellCoordinates.columnIndex + groupIndex * this._workSpace._getCellCount()\n      };\n    } else {\n      return {\n        rowIndex: cellCoordinates.rowIndex,\n        columnIndex: cellCoordinates.columnIndex * this._workSpace._getGroupCount() + groupIndex\n      };\n    }\n  }\n\n  getGroupIndex(rowIndex, columnIndex) {\n    var groupByDay = this._workSpace.isGroupedByDate();\n\n    var groupCount = this._workSpace._getGroupCount();\n\n    if (groupByDay) {\n      return columnIndex % groupCount;\n    } else {\n      return Math.floor(columnIndex / this._workSpace._getCellCount());\n    }\n  }\n\n  calculateHeaderCellRepeatCount() {\n    return this._workSpace._getGroupCount() || 1;\n  }\n\n  insertAllDayRowsIntoDateTable() {\n    return false;\n  }\n\n  getTotalCellCount(groupCount) {\n    groupCount = groupCount || 1;\n    return this._workSpace._getCellCount() * groupCount;\n  }\n\n  getTotalRowCount() {\n    return this._workSpace._getRowCount();\n  }\n\n  calculateTimeCellRepeatCount() {\n    return 1;\n  }\n\n  getWorkSpaceMinWidth() {\n    return getBoundingRect(this._workSpace.$element().get(0)).width - this._workSpace.getTimePanelWidth();\n  }\n\n  getAllDayOffset() {\n    return this._workSpace.getAllDayHeight();\n  }\n\n  getGroupCountClass(groups) {\n    return;\n  }\n\n  getLeftOffset() {\n    return this._workSpace.getTimePanelWidth();\n  }\n\n  _createGroupBoundOffset(startCell, endCell, cellWidth) {\n    var extraOffset = cellWidth / 2;\n    var startOffset = startCell ? startCell.offset().left - extraOffset : 0;\n    var endOffset = endCell ? endCell.offset().left + cellWidth + extraOffset : 0;\n    return {\n      left: startOffset,\n      right: endOffset,\n      top: 0,\n      bottom: 0\n    };\n  }\n\n  _getGroupedByDateBoundOffset($cells, cellWidth) {\n    var lastCellIndex = $cells.length - 1;\n    var startCell = $cells.eq(0);\n    var endCell = $cells.eq(lastCellIndex);\n    return this._createGroupBoundOffset(startCell, endCell, cellWidth);\n  }\n\n  getGroupBoundsOffset(cellCount, $cells, cellWidth, coordinates, groupedDataMap) {\n    if (this._workSpace.isGroupedByDate()) {\n      return this._getGroupedByDateBoundOffset($cells, cellWidth);\n    }\n\n    var startCell;\n    var endCell;\n\n    var cellIndex = this._workSpace.getCellIndexByCoordinates(coordinates);\n\n    var groupIndex = coordinates.groupIndex || Math.floor(cellIndex / cellCount);\n    var currentCellGroup = groupedDataMap.dateTableGroupedMap[groupIndex];\n\n    if (currentCellGroup) {\n      var groupRowLength = currentCellGroup[0].length;\n      var groupStartPosition = currentCellGroup[0][0].position;\n      var groupEndPosition = currentCellGroup[0][groupRowLength - 1].position;\n      startCell = $cells.eq(groupStartPosition.columnIndex);\n      endCell = $cells.eq(groupEndPosition.columnIndex);\n    }\n\n    return this._createGroupBoundOffset(startCell, endCell, cellWidth);\n  }\n\n  shiftIndicator($indicator, height, rtlOffset, groupIndex) {\n    var offset = this._getIndicatorOffset(groupIndex);\n\n    var horizontalOffset = rtlOffset ? rtlOffset - offset : offset;\n    $indicator.css(\"left\", horizontalOffset);\n    $indicator.css(\"top\", height);\n  }\n\n  _getIndicatorOffset(groupIndex) {\n    var groupByDay = this._workSpace.isGroupedByDate();\n\n    return groupByDay ? this._calculateGroupByDateOffset(groupIndex) : this._calculateOffset(groupIndex);\n  }\n\n  _calculateOffset(groupIndex) {\n    return this._workSpace._getCellCount() * this._workSpace.getRoundedCellWidth(groupIndex - 1, 0) * groupIndex + this._workSpace.getIndicatorOffset(groupIndex) + groupIndex;\n  }\n\n  _calculateGroupByDateOffset(groupIndex) {\n    return this._workSpace.getIndicatorOffset(0) * this._workSpace._getGroupCount() + this._workSpace.getRoundedCellWidth(groupIndex - 1, 0) * groupIndex;\n  }\n\n  getShaderOffset(i, width) {\n    var offset = this._workSpace._getCellCount() * this._workSpace.getRoundedCellWidth(i - 1) * i;\n    return this._workSpace.option(\"rtlEnabled\") ? getBoundingRect(this._workSpace._dateTableScrollable.$content().get(0)).width - offset - this._workSpace.getTimePanelWidth() - width : offset;\n  }\n\n  getShaderTopOffset(i) {\n    return -this.getShaderMaxHeight() * (i > 0 ? 1 : 0);\n  }\n\n  getShaderHeight() {\n    var height = this._workSpace.getIndicationHeight();\n\n    return height;\n  }\n\n  getShaderMaxHeight() {\n    return getBoundingRect(this._workSpace._dateTableScrollable.$content().get(0)).height;\n  }\n\n  getShaderWidth(i) {\n    return this._workSpace.getIndicationWidth(i);\n  }\n\n  getScrollableScrollTop(allDay) {\n    return !allDay ? this._workSpace.getScrollable().scrollTop() : 0;\n  }\n\n  addAdditionalGroupCellClasses(cellClass, index, i, j) {\n    var applyUnconditionally = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;\n    cellClass = this._addLastGroupCellClass(cellClass, index, applyUnconditionally);\n    return this._addFirstGroupCellClass(cellClass, index, applyUnconditionally);\n  }\n\n  _addLastGroupCellClass(cellClass, index, applyUnconditionally) {\n    if (applyUnconditionally) {\n      return \"\".concat(cellClass, \" \").concat(LAST_GROUP_CELL_CLASS);\n    }\n\n    var groupByDate = this._workSpace.isGroupedByDate();\n\n    if (groupByDate) {\n      if (index % this._workSpace._getGroupCount() === 0) {\n        return \"\".concat(cellClass, \" \").concat(LAST_GROUP_CELL_CLASS);\n      }\n    } else if (index % this._workSpace._getCellCount() === 0) {\n      return \"\".concat(cellClass, \" \").concat(LAST_GROUP_CELL_CLASS);\n    }\n\n    return cellClass;\n  }\n\n  _addFirstGroupCellClass(cellClass, index, applyUnconditionally) {\n    if (applyUnconditionally) {\n      return \"\".concat(cellClass, \" \").concat(FIRST_GROUP_CELL_CLASS);\n    }\n\n    var groupByDate = this._workSpace.isGroupedByDate();\n\n    if (groupByDate) {\n      if ((index - 1) % this._workSpace._getGroupCount() === 0) {\n        return \"\".concat(cellClass, \" \").concat(FIRST_GROUP_CELL_CLASS);\n      }\n    } else if ((index - 1) % this._workSpace._getCellCount() === 0) {\n      return \"\".concat(cellClass, \" \").concat(FIRST_GROUP_CELL_CLASS);\n    }\n\n    return cellClass;\n  }\n\n}\n\nexport default HorizontalGroupedStrategy;","map":{"version":3,"sources":["C:/Users/Zoran/source/repos/TransportApp/TransportLog-basic/node_modules/devextreme/esm/ui/scheduler/workspaces/ui.scheduler.work_space.grouped.strategy.horizontal.js"],"names":["getBoundingRect","FIRST_GROUP_CELL_CLASS","LAST_GROUP_CELL_CLASS","HorizontalGroupedStrategy","constructor","workSpace","_workSpace","prepareCellIndexes","cellCoordinates","groupIndex","inAllDay","groupByDay","isGroupedByDate","rowIndex","columnIndex","_getCellCount","_getGroupCount","getGroupIndex","groupCount","Math","floor","calculateHeaderCellRepeatCount","insertAllDayRowsIntoDateTable","getTotalCellCount","getTotalRowCount","_getRowCount","calculateTimeCellRepeatCount","getWorkSpaceMinWidth","$element","get","width","getTimePanelWidth","getAllDayOffset","getAllDayHeight","getGroupCountClass","groups","getLeftOffset","_createGroupBoundOffset","startCell","endCell","cellWidth","extraOffset","startOffset","offset","left","endOffset","right","top","bottom","_getGroupedByDateBoundOffset","$cells","lastCellIndex","length","eq","getGroupBoundsOffset","cellCount","coordinates","groupedDataMap","cellIndex","getCellIndexByCoordinates","currentCellGroup","dateTableGroupedMap","groupRowLength","groupStartPosition","position","groupEndPosition","shiftIndicator","$indicator","height","rtlOffset","_getIndicatorOffset","horizontalOffset","css","_calculateGroupByDateOffset","_calculateOffset","getRoundedCellWidth","getIndicatorOffset","getShaderOffset","i","option","_dateTableScrollable","$content","getShaderTopOffset","getShaderMaxHeight","getShaderHeight","getIndicationHeight","getShaderWidth","getIndicationWidth","getScrollableScrollTop","allDay","getScrollable","scrollTop","addAdditionalGroupCellClasses","cellClass","index","j","applyUnconditionally","arguments","_addLastGroupCellClass","_addFirstGroupCellClass","concat","groupByDate"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/ui.scheduler.work_space.grouped.strategy.horizontal.js)\r\n * Version: 22.1.6\r\n * Build date: Tue Oct 18 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    getBoundingRect\r\n} from \"../../../core/utils/position\";\r\nimport {\r\n    FIRST_GROUP_CELL_CLASS,\r\n    LAST_GROUP_CELL_CLASS\r\n} from \"../classes\";\r\nclass HorizontalGroupedStrategy {\r\n    constructor(workSpace) {\r\n        this._workSpace = workSpace\r\n    }\r\n    prepareCellIndexes(cellCoordinates, groupIndex, inAllDay) {\r\n        var groupByDay = this._workSpace.isGroupedByDate();\r\n        if (!groupByDay) {\r\n            return {\r\n                rowIndex: cellCoordinates.rowIndex,\r\n                columnIndex: cellCoordinates.columnIndex + groupIndex * this._workSpace._getCellCount()\r\n            }\r\n        } else {\r\n            return {\r\n                rowIndex: cellCoordinates.rowIndex,\r\n                columnIndex: cellCoordinates.columnIndex * this._workSpace._getGroupCount() + groupIndex\r\n            }\r\n        }\r\n    }\r\n    getGroupIndex(rowIndex, columnIndex) {\r\n        var groupByDay = this._workSpace.isGroupedByDate();\r\n        var groupCount = this._workSpace._getGroupCount();\r\n        if (groupByDay) {\r\n            return columnIndex % groupCount\r\n        } else {\r\n            return Math.floor(columnIndex / this._workSpace._getCellCount())\r\n        }\r\n    }\r\n    calculateHeaderCellRepeatCount() {\r\n        return this._workSpace._getGroupCount() || 1\r\n    }\r\n    insertAllDayRowsIntoDateTable() {\r\n        return false\r\n    }\r\n    getTotalCellCount(groupCount) {\r\n        groupCount = groupCount || 1;\r\n        return this._workSpace._getCellCount() * groupCount\r\n    }\r\n    getTotalRowCount() {\r\n        return this._workSpace._getRowCount()\r\n    }\r\n    calculateTimeCellRepeatCount() {\r\n        return 1\r\n    }\r\n    getWorkSpaceMinWidth() {\r\n        return getBoundingRect(this._workSpace.$element().get(0)).width - this._workSpace.getTimePanelWidth()\r\n    }\r\n    getAllDayOffset() {\r\n        return this._workSpace.getAllDayHeight()\r\n    }\r\n    getGroupCountClass(groups) {\r\n        return\r\n    }\r\n    getLeftOffset() {\r\n        return this._workSpace.getTimePanelWidth()\r\n    }\r\n    _createGroupBoundOffset(startCell, endCell, cellWidth) {\r\n        var extraOffset = cellWidth / 2;\r\n        var startOffset = startCell ? startCell.offset().left - extraOffset : 0;\r\n        var endOffset = endCell ? endCell.offset().left + cellWidth + extraOffset : 0;\r\n        return {\r\n            left: startOffset,\r\n            right: endOffset,\r\n            top: 0,\r\n            bottom: 0\r\n        }\r\n    }\r\n    _getGroupedByDateBoundOffset($cells, cellWidth) {\r\n        var lastCellIndex = $cells.length - 1;\r\n        var startCell = $cells.eq(0);\r\n        var endCell = $cells.eq(lastCellIndex);\r\n        return this._createGroupBoundOffset(startCell, endCell, cellWidth)\r\n    }\r\n    getGroupBoundsOffset(cellCount, $cells, cellWidth, coordinates, groupedDataMap) {\r\n        if (this._workSpace.isGroupedByDate()) {\r\n            return this._getGroupedByDateBoundOffset($cells, cellWidth)\r\n        }\r\n        var startCell;\r\n        var endCell;\r\n        var cellIndex = this._workSpace.getCellIndexByCoordinates(coordinates);\r\n        var groupIndex = coordinates.groupIndex || Math.floor(cellIndex / cellCount);\r\n        var currentCellGroup = groupedDataMap.dateTableGroupedMap[groupIndex];\r\n        if (currentCellGroup) {\r\n            var groupRowLength = currentCellGroup[0].length;\r\n            var groupStartPosition = currentCellGroup[0][0].position;\r\n            var groupEndPosition = currentCellGroup[0][groupRowLength - 1].position;\r\n            startCell = $cells.eq(groupStartPosition.columnIndex);\r\n            endCell = $cells.eq(groupEndPosition.columnIndex)\r\n        }\r\n        return this._createGroupBoundOffset(startCell, endCell, cellWidth)\r\n    }\r\n    shiftIndicator($indicator, height, rtlOffset, groupIndex) {\r\n        var offset = this._getIndicatorOffset(groupIndex);\r\n        var horizontalOffset = rtlOffset ? rtlOffset - offset : offset;\r\n        $indicator.css(\"left\", horizontalOffset);\r\n        $indicator.css(\"top\", height)\r\n    }\r\n    _getIndicatorOffset(groupIndex) {\r\n        var groupByDay = this._workSpace.isGroupedByDate();\r\n        return groupByDay ? this._calculateGroupByDateOffset(groupIndex) : this._calculateOffset(groupIndex)\r\n    }\r\n    _calculateOffset(groupIndex) {\r\n        return this._workSpace._getCellCount() * this._workSpace.getRoundedCellWidth(groupIndex - 1, 0) * groupIndex + this._workSpace.getIndicatorOffset(groupIndex) + groupIndex\r\n    }\r\n    _calculateGroupByDateOffset(groupIndex) {\r\n        return this._workSpace.getIndicatorOffset(0) * this._workSpace._getGroupCount() + this._workSpace.getRoundedCellWidth(groupIndex - 1, 0) * groupIndex\r\n    }\r\n    getShaderOffset(i, width) {\r\n        var offset = this._workSpace._getCellCount() * this._workSpace.getRoundedCellWidth(i - 1) * i;\r\n        return this._workSpace.option(\"rtlEnabled\") ? getBoundingRect(this._workSpace._dateTableScrollable.$content().get(0)).width - offset - this._workSpace.getTimePanelWidth() - width : offset\r\n    }\r\n    getShaderTopOffset(i) {\r\n        return -this.getShaderMaxHeight() * (i > 0 ? 1 : 0)\r\n    }\r\n    getShaderHeight() {\r\n        var height = this._workSpace.getIndicationHeight();\r\n        return height\r\n    }\r\n    getShaderMaxHeight() {\r\n        return getBoundingRect(this._workSpace._dateTableScrollable.$content().get(0)).height\r\n    }\r\n    getShaderWidth(i) {\r\n        return this._workSpace.getIndicationWidth(i)\r\n    }\r\n    getScrollableScrollTop(allDay) {\r\n        return !allDay ? this._workSpace.getScrollable().scrollTop() : 0\r\n    }\r\n    addAdditionalGroupCellClasses(cellClass, index, i, j) {\r\n        var applyUnconditionally = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;\r\n        cellClass = this._addLastGroupCellClass(cellClass, index, applyUnconditionally);\r\n        return this._addFirstGroupCellClass(cellClass, index, applyUnconditionally)\r\n    }\r\n    _addLastGroupCellClass(cellClass, index, applyUnconditionally) {\r\n        if (applyUnconditionally) {\r\n            return \"\".concat(cellClass, \" \").concat(LAST_GROUP_CELL_CLASS)\r\n        }\r\n        var groupByDate = this._workSpace.isGroupedByDate();\r\n        if (groupByDate) {\r\n            if (index % this._workSpace._getGroupCount() === 0) {\r\n                return \"\".concat(cellClass, \" \").concat(LAST_GROUP_CELL_CLASS)\r\n            }\r\n        } else if (index % this._workSpace._getCellCount() === 0) {\r\n            return \"\".concat(cellClass, \" \").concat(LAST_GROUP_CELL_CLASS)\r\n        }\r\n        return cellClass\r\n    }\r\n    _addFirstGroupCellClass(cellClass, index, applyUnconditionally) {\r\n        if (applyUnconditionally) {\r\n            return \"\".concat(cellClass, \" \").concat(FIRST_GROUP_CELL_CLASS)\r\n        }\r\n        var groupByDate = this._workSpace.isGroupedByDate();\r\n        if (groupByDate) {\r\n            if ((index - 1) % this._workSpace._getGroupCount() === 0) {\r\n                return \"\".concat(cellClass, \" \").concat(FIRST_GROUP_CELL_CLASS)\r\n            }\r\n        } else if ((index - 1) % this._workSpace._getCellCount() === 0) {\r\n            return \"\".concat(cellClass, \" \").concat(FIRST_GROUP_CELL_CLASS)\r\n        }\r\n        return cellClass\r\n    }\r\n}\r\nexport default HorizontalGroupedStrategy;\r\n"]},"metadata":{},"sourceType":"module"}