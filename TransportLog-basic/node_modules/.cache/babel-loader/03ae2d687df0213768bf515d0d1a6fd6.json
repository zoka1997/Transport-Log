{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/view_model/grouped_data_map_provider.js)\r\n * Version: 22.1.6\r\n * Build date: Tue Oct 18 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport dateUtils from \"../../../../core/utils/date\";\nimport { isDateAndTimeView } from \"../../../../renovation/ui/scheduler/view_model/to_test/views/utils/base\";\nexport class GroupedDataMapProvider {\n  constructor(viewDataGenerator, viewDataMap, completeViewDataMap, viewOptions) {\n    this.groupedDataMap = viewDataGenerator.generateGroupedDataMap(viewDataMap);\n    this.completeViewDataMap = completeViewDataMap;\n    this._viewOptions = viewOptions;\n  }\n\n  getGroupStartDate(groupIndex) {\n    var firstRow = this.getFirstGroupRow(groupIndex);\n\n    if (firstRow) {\n      var {\n        startDate: startDate\n      } = firstRow[0].cellData;\n      return startDate;\n    }\n  }\n\n  getGroupEndDate(groupIndex) {\n    var lastRow = this.getLastGroupRow(groupIndex);\n\n    if (lastRow) {\n      var lastColumnIndex = lastRow.length - 1;\n      var {\n        cellData: cellData\n      } = lastRow[lastColumnIndex];\n      var {\n        endDate: endDate\n      } = cellData;\n      return endDate;\n    }\n  }\n\n  findGroupCellStartDate(groupIndex, startDate, endDate, isAllDay, isFindByDate) {\n    if (isAllDay) {\n      return this.findAllDayGroupCellStartDate(groupIndex, startDate);\n    }\n\n    var groupData = this.getGroupFromDateTableGroupMap(groupIndex);\n\n    var checkCellStartDate = (rowIndex, columnIndex) => {\n      var {\n        cellData: cellData\n      } = groupData[rowIndex][columnIndex];\n      var {\n        startDate: secondMin,\n        endDate: secondMax\n      } = cellData;\n\n      if (isFindByDate) {\n        secondMin = dateUtils.trimTime(secondMin);\n        secondMax = dateUtils.setToDayEnd(secondMin);\n      }\n\n      if (dateUtils.intervalsOverlap({\n        firstMin: startDate,\n        firstMax: endDate,\n        secondMin: secondMin,\n        secondMax: secondMax\n      })) {\n        return secondMin;\n      }\n    };\n\n    var startDateVerticalSearch = (() => {\n      var cellCount = groupData[0].length;\n\n      for (var columnIndex = 0; columnIndex < cellCount; ++columnIndex) {\n        for (var rowIndex = 0; rowIndex < groupData.length; ++rowIndex) {\n          var result = checkCellStartDate(rowIndex, columnIndex);\n\n          if (result) {\n            return result;\n          }\n        }\n      }\n    })();\n\n    var startDateHorizontalSearch = (() => {\n      for (var rowIndex = 0; rowIndex < groupData.length; ++rowIndex) {\n        var row = groupData[rowIndex];\n\n        for (var columnIndex = 0; columnIndex < row.length; ++columnIndex) {\n          var result = checkCellStartDate(rowIndex, columnIndex);\n\n          if (result) {\n            return result;\n          }\n        }\n      }\n    })();\n\n    return startDateVerticalSearch > startDateHorizontalSearch ? startDateHorizontalSearch : startDateVerticalSearch;\n  }\n\n  findAllDayGroupCellStartDate(groupIndex, startDate) {\n    var groupStartDate = this.getGroupStartDate(groupIndex);\n    return groupStartDate > startDate ? groupStartDate : startDate;\n  }\n\n  findCellPositionInMap(cellInfo) {\n    var {\n      groupIndex: groupIndex,\n      startDate: startDate,\n      isAllDay: isAllDay,\n      index: index\n    } = cellInfo;\n    var startTime = isAllDay ? dateUtils.trimTime(startDate).getTime() : startDate.getTime();\n\n    var isStartDateInCell = cellData => {\n      if (!isDateAndTimeView(this._viewOptions.viewType)) {\n        return dateUtils.sameDate(startDate, cellData.startDate);\n      }\n\n      var cellStartTime = cellData.startDate.getTime();\n      var cellEndTime = cellData.endDate.getTime();\n      return isAllDay ? cellData.allDay && startTime >= cellStartTime && startTime <= cellEndTime : startTime >= cellStartTime && startTime < cellEndTime;\n    };\n\n    var {\n      allDayPanelGroupedMap: allDayPanelGroupedMap,\n      dateTableGroupedMap: dateTableGroupedMap\n    } = this.groupedDataMap;\n    var rows = isAllDay && !this._viewOptions.isVerticalGrouping ? [allDayPanelGroupedMap[groupIndex]] || [] : dateTableGroupedMap[groupIndex] || [];\n\n    for (var rowIndex = 0; rowIndex < rows.length; ++rowIndex) {\n      var row = rows[rowIndex];\n\n      for (var columnIndex = 0; columnIndex < row.length; ++columnIndex) {\n        var cell = row[columnIndex];\n        var {\n          cellData: cellData\n        } = cell;\n\n        if (this._isSameGroupIndexAndIndex(cellData, groupIndex, index)) {\n          if (isStartDateInCell(cellData)) {\n            return cell.position;\n          }\n        }\n      }\n    }\n\n    return;\n  }\n\n  _isSameGroupIndexAndIndex(cellData, groupIndex, index) {\n    return cellData.groupIndex === groupIndex && (void 0 === index || cellData.index === index);\n  }\n\n  getCellsGroup(groupIndex) {\n    var {\n      dateTableGroupedMap: dateTableGroupedMap\n    } = this.groupedDataMap;\n    var groupData = dateTableGroupedMap[groupIndex];\n\n    if (groupData) {\n      var {\n        cellData: cellData\n      } = groupData[0][0];\n      return cellData.groups;\n    }\n  }\n\n  getCompletedGroupsInfo() {\n    var {\n      dateTableGroupedMap: dateTableGroupedMap\n    } = this.groupedDataMap;\n    return dateTableGroupedMap.map(groupData => {\n      var firstCell = groupData[0][0];\n      var {\n        allDay: allDay,\n        groupIndex: groupIndex\n      } = firstCell.cellData;\n      return {\n        allDay: allDay,\n        groupIndex: groupIndex,\n        startDate: this.getGroupStartDate(groupIndex),\n        endDate: this.getGroupEndDate(groupIndex)\n      };\n    }).filter(_ref => {\n      var {\n        startDate: startDate\n      } = _ref;\n      return !!startDate;\n    });\n  }\n\n  getGroupIndices() {\n    return this.getCompletedGroupsInfo().map(_ref2 => {\n      var {\n        groupIndex: groupIndex\n      } = _ref2;\n      return groupIndex;\n    });\n  }\n\n  getGroupFromDateTableGroupMap(groupIndex) {\n    var {\n      dateTableGroupedMap: dateTableGroupedMap\n    } = this.groupedDataMap;\n    return dateTableGroupedMap[groupIndex];\n  }\n\n  getFirstGroupRow(groupIndex) {\n    var groupedData = this.getGroupFromDateTableGroupMap(groupIndex);\n\n    if (groupedData) {\n      var {\n        cellData: cellData\n      } = groupedData[0][0];\n      return !cellData.allDay ? groupedData[0] : groupedData[1];\n    }\n  }\n\n  getLastGroupRow(groupIndex) {\n    var {\n      dateTableGroupedMap: dateTableGroupedMap\n    } = this.groupedDataMap;\n    var groupedData = dateTableGroupedMap[groupIndex];\n\n    if (groupedData) {\n      var lastRowIndex = groupedData.length - 1;\n      return groupedData[lastRowIndex];\n    }\n  }\n\n  getLastGroupCellPosition(groupIndex) {\n    var groupRow = this.getLastGroupRow(groupIndex);\n    return null === groupRow || void 0 === groupRow ? void 0 : groupRow[(null === groupRow || void 0 === groupRow ? void 0 : groupRow.length) - 1].position;\n  }\n\n  getRowCountInGroup(groupIndex) {\n    var groupRow = this.getLastGroupRow(groupIndex);\n    var cellAmount = groupRow.length;\n    var lastCellData = groupRow[cellAmount - 1].cellData;\n    var lastCellIndex = lastCellData.index;\n    return (lastCellIndex + 1) / groupRow.length;\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Zoran/source/repos/TransportApp/TransportLog-basic/node_modules/devextreme/esm/ui/scheduler/workspaces/view_model/grouped_data_map_provider.js"],"names":["dateUtils","isDateAndTimeView","GroupedDataMapProvider","constructor","viewDataGenerator","viewDataMap","completeViewDataMap","viewOptions","groupedDataMap","generateGroupedDataMap","_viewOptions","getGroupStartDate","groupIndex","firstRow","getFirstGroupRow","startDate","cellData","getGroupEndDate","lastRow","getLastGroupRow","lastColumnIndex","length","endDate","findGroupCellStartDate","isAllDay","isFindByDate","findAllDayGroupCellStartDate","groupData","getGroupFromDateTableGroupMap","checkCellStartDate","rowIndex","columnIndex","secondMin","secondMax","trimTime","setToDayEnd","intervalsOverlap","firstMin","firstMax","startDateVerticalSearch","cellCount","result","startDateHorizontalSearch","row","groupStartDate","findCellPositionInMap","cellInfo","index","startTime","getTime","isStartDateInCell","viewType","sameDate","cellStartTime","cellEndTime","allDay","allDayPanelGroupedMap","dateTableGroupedMap","rows","isVerticalGrouping","cell","_isSameGroupIndexAndIndex","position","getCellsGroup","groups","getCompletedGroupsInfo","map","firstCell","filter","_ref","getGroupIndices","_ref2","groupedData","lastRowIndex","getLastGroupCellPosition","groupRow","getRowCountInGroup","cellAmount","lastCellData","lastCellIndex"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/view_model/grouped_data_map_provider.js)\r\n * Version: 22.1.6\r\n * Build date: Tue Oct 18 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport dateUtils from \"../../../../core/utils/date\";\r\nimport {\r\n    isDateAndTimeView\r\n} from \"../../../../renovation/ui/scheduler/view_model/to_test/views/utils/base\";\r\nexport class GroupedDataMapProvider {\r\n    constructor(viewDataGenerator, viewDataMap, completeViewDataMap, viewOptions) {\r\n        this.groupedDataMap = viewDataGenerator.generateGroupedDataMap(viewDataMap);\r\n        this.completeViewDataMap = completeViewDataMap;\r\n        this._viewOptions = viewOptions\r\n    }\r\n    getGroupStartDate(groupIndex) {\r\n        var firstRow = this.getFirstGroupRow(groupIndex);\r\n        if (firstRow) {\r\n            var {\r\n                startDate: startDate\r\n            } = firstRow[0].cellData;\r\n            return startDate\r\n        }\r\n    }\r\n    getGroupEndDate(groupIndex) {\r\n        var lastRow = this.getLastGroupRow(groupIndex);\r\n        if (lastRow) {\r\n            var lastColumnIndex = lastRow.length - 1;\r\n            var {\r\n                cellData: cellData\r\n            } = lastRow[lastColumnIndex];\r\n            var {\r\n                endDate: endDate\r\n            } = cellData;\r\n            return endDate\r\n        }\r\n    }\r\n    findGroupCellStartDate(groupIndex, startDate, endDate, isAllDay, isFindByDate) {\r\n        if (isAllDay) {\r\n            return this.findAllDayGroupCellStartDate(groupIndex, startDate)\r\n        }\r\n        var groupData = this.getGroupFromDateTableGroupMap(groupIndex);\r\n        var checkCellStartDate = (rowIndex, columnIndex) => {\r\n            var {\r\n                cellData: cellData\r\n            } = groupData[rowIndex][columnIndex];\r\n            var {\r\n                startDate: secondMin,\r\n                endDate: secondMax\r\n            } = cellData;\r\n            if (isFindByDate) {\r\n                secondMin = dateUtils.trimTime(secondMin);\r\n                secondMax = dateUtils.setToDayEnd(secondMin)\r\n            }\r\n            if (dateUtils.intervalsOverlap({\r\n                    firstMin: startDate,\r\n                    firstMax: endDate,\r\n                    secondMin: secondMin,\r\n                    secondMax: secondMax\r\n                })) {\r\n                return secondMin\r\n            }\r\n        };\r\n        var startDateVerticalSearch = (() => {\r\n            var cellCount = groupData[0].length;\r\n            for (var columnIndex = 0; columnIndex < cellCount; ++columnIndex) {\r\n                for (var rowIndex = 0; rowIndex < groupData.length; ++rowIndex) {\r\n                    var result = checkCellStartDate(rowIndex, columnIndex);\r\n                    if (result) {\r\n                        return result\r\n                    }\r\n                }\r\n            }\r\n        })();\r\n        var startDateHorizontalSearch = (() => {\r\n            for (var rowIndex = 0; rowIndex < groupData.length; ++rowIndex) {\r\n                var row = groupData[rowIndex];\r\n                for (var columnIndex = 0; columnIndex < row.length; ++columnIndex) {\r\n                    var result = checkCellStartDate(rowIndex, columnIndex);\r\n                    if (result) {\r\n                        return result\r\n                    }\r\n                }\r\n            }\r\n        })();\r\n        return startDateVerticalSearch > startDateHorizontalSearch ? startDateHorizontalSearch : startDateVerticalSearch\r\n    }\r\n    findAllDayGroupCellStartDate(groupIndex, startDate) {\r\n        var groupStartDate = this.getGroupStartDate(groupIndex);\r\n        return groupStartDate > startDate ? groupStartDate : startDate\r\n    }\r\n    findCellPositionInMap(cellInfo) {\r\n        var {\r\n            groupIndex: groupIndex,\r\n            startDate: startDate,\r\n            isAllDay: isAllDay,\r\n            index: index\r\n        } = cellInfo;\r\n        var startTime = isAllDay ? dateUtils.trimTime(startDate).getTime() : startDate.getTime();\r\n        var isStartDateInCell = cellData => {\r\n            if (!isDateAndTimeView(this._viewOptions.viewType)) {\r\n                return dateUtils.sameDate(startDate, cellData.startDate)\r\n            }\r\n            var cellStartTime = cellData.startDate.getTime();\r\n            var cellEndTime = cellData.endDate.getTime();\r\n            return isAllDay ? cellData.allDay && startTime >= cellStartTime && startTime <= cellEndTime : startTime >= cellStartTime && startTime < cellEndTime\r\n        };\r\n        var {\r\n            allDayPanelGroupedMap: allDayPanelGroupedMap,\r\n            dateTableGroupedMap: dateTableGroupedMap\r\n        } = this.groupedDataMap;\r\n        var rows = isAllDay && !this._viewOptions.isVerticalGrouping ? [allDayPanelGroupedMap[groupIndex]] || [] : dateTableGroupedMap[groupIndex] || [];\r\n        for (var rowIndex = 0; rowIndex < rows.length; ++rowIndex) {\r\n            var row = rows[rowIndex];\r\n            for (var columnIndex = 0; columnIndex < row.length; ++columnIndex) {\r\n                var cell = row[columnIndex];\r\n                var {\r\n                    cellData: cellData\r\n                } = cell;\r\n                if (this._isSameGroupIndexAndIndex(cellData, groupIndex, index)) {\r\n                    if (isStartDateInCell(cellData)) {\r\n                        return cell.position\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return\r\n    }\r\n    _isSameGroupIndexAndIndex(cellData, groupIndex, index) {\r\n        return cellData.groupIndex === groupIndex && (void 0 === index || cellData.index === index)\r\n    }\r\n    getCellsGroup(groupIndex) {\r\n        var {\r\n            dateTableGroupedMap: dateTableGroupedMap\r\n        } = this.groupedDataMap;\r\n        var groupData = dateTableGroupedMap[groupIndex];\r\n        if (groupData) {\r\n            var {\r\n                cellData: cellData\r\n            } = groupData[0][0];\r\n            return cellData.groups\r\n        }\r\n    }\r\n    getCompletedGroupsInfo() {\r\n        var {\r\n            dateTableGroupedMap: dateTableGroupedMap\r\n        } = this.groupedDataMap;\r\n        return dateTableGroupedMap.map(groupData => {\r\n            var firstCell = groupData[0][0];\r\n            var {\r\n                allDay: allDay,\r\n                groupIndex: groupIndex\r\n            } = firstCell.cellData;\r\n            return {\r\n                allDay: allDay,\r\n                groupIndex: groupIndex,\r\n                startDate: this.getGroupStartDate(groupIndex),\r\n                endDate: this.getGroupEndDate(groupIndex)\r\n            }\r\n        }).filter(_ref => {\r\n            var {\r\n                startDate: startDate\r\n            } = _ref;\r\n            return !!startDate\r\n        })\r\n    }\r\n    getGroupIndices() {\r\n        return this.getCompletedGroupsInfo().map(_ref2 => {\r\n            var {\r\n                groupIndex: groupIndex\r\n            } = _ref2;\r\n            return groupIndex\r\n        })\r\n    }\r\n    getGroupFromDateTableGroupMap(groupIndex) {\r\n        var {\r\n            dateTableGroupedMap: dateTableGroupedMap\r\n        } = this.groupedDataMap;\r\n        return dateTableGroupedMap[groupIndex]\r\n    }\r\n    getFirstGroupRow(groupIndex) {\r\n        var groupedData = this.getGroupFromDateTableGroupMap(groupIndex);\r\n        if (groupedData) {\r\n            var {\r\n                cellData: cellData\r\n            } = groupedData[0][0];\r\n            return !cellData.allDay ? groupedData[0] : groupedData[1]\r\n        }\r\n    }\r\n    getLastGroupRow(groupIndex) {\r\n        var {\r\n            dateTableGroupedMap: dateTableGroupedMap\r\n        } = this.groupedDataMap;\r\n        var groupedData = dateTableGroupedMap[groupIndex];\r\n        if (groupedData) {\r\n            var lastRowIndex = groupedData.length - 1;\r\n            return groupedData[lastRowIndex]\r\n        }\r\n    }\r\n    getLastGroupCellPosition(groupIndex) {\r\n        var groupRow = this.getLastGroupRow(groupIndex);\r\n        return null === groupRow || void 0 === groupRow ? void 0 : groupRow[(null === groupRow || void 0 === groupRow ? void 0 : groupRow.length) - 1].position\r\n    }\r\n    getRowCountInGroup(groupIndex) {\r\n        var groupRow = this.getLastGroupRow(groupIndex);\r\n        var cellAmount = groupRow.length;\r\n        var lastCellData = groupRow[cellAmount - 1].cellData;\r\n        var lastCellIndex = lastCellData.index;\r\n        return (lastCellIndex + 1) / groupRow.length\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}