/**
 * DevExtreme (esm/renovation/ui/grids/data_grid_next/scrolling/utils.js)
 * Version: 22.1.6
 * Build date: Tue Oct 18 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
export var DEFAULT_ROW_HEIGHT = 20;
export var calculateRowHeight = (visibleRowHeights, itemHeights) => {
    var itemsSize = 0;
    var rowCount = 0;
    var result = DEFAULT_ROW_HEIGHT;
    if (visibleRowHeights.length) {
        itemsSize = visibleRowHeights.reduce((sum, item) => sum + item, 0);
        rowCount = visibleRowHeights.length
    } else {
        var rowIndices = Object.keys(itemHeights);
        if (rowIndices.length) {
            itemsSize = rowIndices.reduce((sum, key) => sum + itemHeights[key], 0);
            rowCount = rowIndices.length
        }
    }
    if (itemsSize > 0 && rowCount > 0) {
        result = itemsSize / rowCount
    }
    return result
};
export var calculateItemHeights = (visibleRows, rowHeights) => {
    var calculatedRowSizes = [];
    var itemSize = 0;
    var lastLoadIndex = -1;
    rowHeights.forEach((height, index) => {
        var currentItem = visibleRows[index];
        if (!currentItem) {
            return
        }
        if (lastLoadIndex >= 0 && lastLoadIndex !== currentItem.loadIndex) {
            calculatedRowSizes.push(itemSize);
            itemSize = 0
        }
        lastLoadIndex = currentItem.loadIndex;
        itemSize += height
    });
    itemSize > 0 && calculatedRowSizes.push(itemSize);
    return calculatedRowSizes
};
export var calculateViewportItemIndex = (topScrollPosition, rowHeight, itemHeights) => {
    var position = topScrollPosition;
    var defaultItemSize = rowHeight;
    var offset = 0;
    var itemOffset = 0;
    var itemOffsetsWithSize = Object.keys(itemHeights).concat("-1");
    for (var i = 0; i < itemOffsetsWithSize.length && offset < position; i += 1) {
        var itemOffsetWithSize = parseInt(itemOffsetsWithSize[i], 10);
        var itemOffsetDiff = (position - offset) / defaultItemSize;
        if (itemOffsetWithSize < 0 || itemOffset + itemOffsetDiff < itemOffsetWithSize) {
            itemOffset += itemOffsetDiff;
            break
        } else {
            itemOffsetDiff = itemOffsetWithSize - itemOffset;
            offset += itemOffsetDiff * defaultItemSize;
            itemOffset += itemOffsetDiff
        }
        var itemSize = itemHeights[itemOffsetWithSize];
        offset += itemSize;
        itemOffset += offset < position ? 1 : (position - offset + itemSize) / itemSize
    }
    return Math.round(50 * itemOffset) / 50
};
export var getVirtualContentOffset = (type, itemIndex, totalCount, itemHeights, rowHeight) => {
    var itemCount = itemIndex;
    if (!itemCount) {
        return 0
    }
    var offset = 0;
    Object.keys(itemHeights).forEach(currentItemIndex => {
        if (!itemCount) {
            return
        }
        var isBottom = "bottom" === type;
        var currentIndex = currentItemIndex;
        if (isBottom ? currentIndex >= totalCount - itemIndex : currentIndex < itemIndex) {
            offset += itemHeights[currentIndex];
            itemCount -= 1
        }
    });
    return Math.floor(offset + itemCount * rowHeight)
};
export var getTopScrollPosition = (pageIndex, pageSize, itemHeights, rowHeight) => {
    var scrollPosition = 0;
    var itemIndex = pageIndex * pageSize;
    scrollPosition = itemIndex * rowHeight;
    for (var index in itemHeights) {
        if (parseInt(index, 10) < itemIndex) {
            scrollPosition += itemHeights[index] - rowHeight
        }
    }
    return scrollPosition
};
export var getNormalizedPageSize = pageSize => "all" === pageSize ? 0 : pageSize;
export var calculatePageIndexByItemIndex = (itemIndex, pageSize, totalCount) => {
    var maxPageIndex = pageSize > 0 ? Math.floor(totalCount / pageSize) : 0;
    var pageIndex = pageSize > 0 ? Math.floor(itemIndex / pageSize) : 0;
    return Math.min(maxPageIndex, pageIndex)
};
